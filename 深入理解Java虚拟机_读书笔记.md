# 《深入理解Java虚拟机》读书笔记

[TOC]

## 一、自动内存管理机制

### 1. Java内存区域

* 程序计数器
  * **较小**的一块内存**空间**，可以看做是**当前线程**执行的字节码的**行号指示器**。**字节码解释器工作时就是通过改变这个计数器的值来取下一条需要执行的字节码指令**，分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。
  * 如果线程正在执行的是Java方法，计数器存储的是当前执行字节码指令地址；如果执行的本地方法（Native），这个计数器值为空（Undefined）。
  * 此区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
* Java虚拟机栈
  * 线程私有，生命周期与线程相同。
  * 描述Java方法执行的内存模型，每个方法执行的时候都会创建一个**栈帧**，用于存储**局部变量表、操作数栈、动态链接、方法出入口**等信息。每一个方法从调用到执行完成都对应一个栈帧在虚拟机栈中从入栈到出栈的过程。
  * 局部变量表存放的是编译期可知的基本数据类型（3类8种），对象引用类型。
  * 64位长度的long和double类型的数据占2个局部变量空间（slot）,其余的数据类型占1个。
  * 此区域规定了两种异常状况：如果线程请求栈深度大于虚拟机所允许栈深度，抛出StackOverFlowError异常；如果虚拟机栈可以动态扩展（当前大部分Java虚拟机都可动态扩展），如果扩展时无法申请到足够内存，抛出OutOfMemoryError异常。
* 本地方法栈
  * 与虚拟机栈类似，区别是Java虚拟机栈执行的是Java方法（字节码），本地方法栈执行的是本地方法（Native修饰的方法）。
  * 有的虚拟机讲本地方法栈和虚拟机栈合二为一。
  * 本地方法栈也会抛出StackOverFlowError和OutOfMemoryError异常。
* Java堆
  * Java虚拟机所管理的内存中最大的一块区域，被**所有线程共享**，在虚拟机启动时创建。
  * 唯一目的，存入Java对象实例。分配大部分实例（JIT编译器的发展与逃逸分析技术的成熟，栈上分配、标量替换优化技术）。
  * Java堆是垃圾收集器管理的主要区域。
    * 从内存回收的角度，由于现在收集器基本都是采用分代收集算法，所以Java堆还可以细分为：新生代和老年代，再细分Eden空间、From Survivor空间和To Survivor空间等；
    * 从内存分配角度，线程共享的Java堆中可能划分出多个**线程私有的分配缓冲区（Thread Loacl Allocation Buffer TLAB）**;
  * 根据Java虚拟机规范，Java堆可以处理物理上不连续的内存空间，只要逻辑上连续即可，类似于磁盘空间。在实现时，既可以固定大小，也可以动态扩展（通过-Xmx和-Xms控制）。
* 方法区
  * **所有线程共享**，存储被虚拟机加载的**类信息、常量、静态变量、即时编译器编译后的代码**等数据。
* 运行时常量池
  * 运行时常量池是方法区的一部分。
  * Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池。
  * 可能抛出OutOfMemoryError异常。
* 直接内存
  * 直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是**被频繁使用**。
  * JDK1.4引入的NIO（new input/output）类，引入了一种基于管道和缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的`DirectByteBuffer`对象作为这块内存的引用进行操作（避免Java堆和Native堆来回复制数据）。

### 2. 对象管理

* 对象的创建
  * 检测是否被加载过。当虚拟机遇到一条new指令时，首先检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用对应的类是否已被加载、解析和初始化。如果没有，先执行类加载过程。
  * 对象内存分配。类加载检查通过后，虚拟机会新生对象分配内存。对象所需内存大小在类加载完成后便可完全确定，为对象分配内存的过程相当于在Java堆中为对象划出一块大小确定的区域。
    * 堆内存规整，所有用过的内存在一边，另一边是空闲内存，中间存放一个指针作为分界点的指示器，所分配内存就是把指针向空闲区域移动一段对象大小相等的区域，称为“指针碰撞”。
    * 堆内存不规整，已使用的内存和空闲内存相互交错，没办法简单的指针碰撞，虚拟机必须维护一个列表，记录哪块内存可用，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。
    * 哪种方式分配取决于堆内存是否规整，堆是否规整又取决于所采用的垃圾回收器是否带有压缩整理功能。因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的收集算法是指针碰撞；而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。
  * 分配过程中的问题，指针的分配是线程不安全的。除了要考虑可用空间的划分之外，还需要考虑对象创建在虚拟机中是否为非常频繁的行为。即使仅仅修改一个指针所指向的位置，在并发情况下也不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针分配了内存。解决该问题有两种方案：
    * 分配内存空间的动作进行同步处理——实际上虚拟机采用的是CAS加上失败后重试的方式保证更新操作的原子性。
    * 把内存的分配动作按线程划分到不同空间中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Loacl Allocation Buffer,TLAB）。哪个线程要分配内存就在哪个线程的TLAB上分配，只有TLAB用完并且要分配新的TLAB时，才需要同步操作。虚拟机设置是否使用TLAB,可以通过参数-XX:+/-UseTLAB参数来设定。
  * 内存初始化，不包含对象头。内存分配完成之后，虚拟机需要将分配的内存初始化为零值（不包含对象头），如果使用TLAB，这一操作可以提前至TLAB分配时进行。这一操作，保证了对象的实例字段在java代码中不赋初始值也可以直接使用，程序能访问这些字段的数据类型所对应的零值。
  * 设置对象头。设置该对象属于哪个类、如何才能找到类的元数据信息（描述程序过程的数据）、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象头中（Object Header）。根据虚拟机当前运行状态不同，如是否启用偏向锁等，对象头会有不同的设置方式。
  * Java程序角度初始化。在虚拟机的角度，新的对象已经产生，但是从Java程序的角度来看，对象的创建才刚刚开始——还没有执行<init>方法，所有的字段都为零。一般来说，执行完new指令后会接着执行init方法，把对象按照程序员的意愿进行初始化，这样真正可用的对象才算完全创建出来。

* 对象的布局

  在HotSpot虚拟机中，对象的内存布局分为三个区域，对象头（Header）、实例数据（Instance data）和对齐填充（Padding）。

  * 对象头包含两部分：
    * 第一部分储存对象自身运行时的数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据长度32bit/64bit(32位/64位操作系统)，官方称为“Mark Word”。对象需要存储的运行时数据会很多，远远超过32位或64位bitmap结构所能记录的限度，所以为考虑虚拟机空间效率，Mark Word设计为非固定的数据结构，以便在极小的空间内存存储尽量多的信息。
    * 另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机可以通过这个指针确定该对象所有哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保存类型指针，换句话说，查找对象的元数据信息不一定要通过对象本身。
    * 如果对象是一个数组，那么对象头中必须有一块用于记录数组长度的数据。因为虚拟机可以通过普通对象的元数据信息知道对象的大小，而数组的元数据中不能确定数组的大小。
  * 实例数据。实例数据是对象真正存储的有效信息，也是程序代码中定义的各种类型字段的内容。无论是从父类继承下来，还是子类中定义的，都要记录下来。这部分存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义的顺序影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers）,从分配策略可以看出相同宽度的字段总是被分配在一起。在满足这个前提下，父类中定义的变量会出现在子类之前，如果CompactFields参数为true（默认为true）,子类中较窄的变量也可能插入到父类变量的空隙中。
  * 对齐填充。该部分并不是必然存在，也没有特别含义，仅起到占位符的作用。由于HotSpot VM的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，也就是对象的大小必须是8字节的整数倍，而对象头的大小正好是8字节的整数倍（1倍或2倍），因此当对象实例数据部分没有对齐时，就需要对齐填充来补全。

* 对象的使用。建立对象是为了使用对象，Java程序需要通过栈上的reference数据来操作堆上的具体对象。有用reference类型在虚拟机规范中只规定了一个对象的引用，并没有定义这个引入应该通过何种方式，访问堆中对象的具体地址，所以对象访问方式由虚拟机实现决定。目前主流采用句柄和直接引用两种。

  * 句柄。如果使用句柄访问，在Java堆中会划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中又包含了对象的实例数据（堆）和类型数据（方法区）各自的具体地址信息。

    ![img](http://img.mp.itc.cn/upload/20170604/34a8538fdca241568261997fb1742bcb_th.jpg) 

    

  * 直接引用。堆对象的布局得考虑类型数据的如何放置，栈中直接存储的是对象在堆中的具体地址。

    ![img](http://www.cnblogs.com/images/cnblogs_com/gscq073240/1061819/o_%e9%80%9a%e8%bf%87%e7%9b%b4%e6%8e%a5%e6%8c%87%e9%92%88%e8%ae%bf%e9%97%ae%e5%af%b9%e8%b1%a1.png) 

  * 总结。直接访问最大的好处就是速度快，节省了一次指针定位的时间开销，由于对象的访问是非常频繁的，累计出来的节省开销就非常可观，Sun HotSpot虚拟机采用的是直接访问。

### 3.内存溢出

  * 堆OOM
    * 对象数量超过最大堆容量限制
    * 定位内存泄露和内存溢出
  * 栈和本地方法栈
    * 线程请求栈的深度超过虚拟机所允许的最大深度。（stack overflow error）
    * 虚拟机在扩展时无法申请到足够多的内存空间。（OOM）
  * 方法区和运行时常量池
  * 本地直接内存溢出

## 二、垃圾收集器和内存分配策略

### 1.对象已死?

* 对象是否存活
  * 引用计数算法
    * 给对象中添加一个引用计数器，每当有一个地方引用它，计数器加1；引用失效，计数器减1。任何时刻计数器为0，表示该对象没有被使用。

    * 无法解决循环引用问题。虚拟机不是通过引用计数算法判断对象是否存活的。

      ![img](http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/YUYc62VIvE2xHo4wJUED2bXDvGMrEC5ftstZPicT32mabz2O1Y9GFpib3dUgpKL3oyJQe1tQBIwNHxGCv1rYeNbA/640?wx_fmt=png) 

  * 可达性分析算法

    * 通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）,当一个对象到GC Roots没有任何引用链相连，则证明该对象是不可用的。
    * 在Java语言中，可作为GC Roots对象包括以下几种：
      * 虚拟机栈（栈帧中的本地变量表）中引用的对象。
      * 方法区中类静态属性所引用的对象。
      * 方法区中常量引用的对象。
      * 本地方法栈中JNI（Native方法）引用的对象。

* 引用

  * 强引用（Strong Reference），强引用在程序中经常出现，如new关键字创建对象时引用，只要强引用还在，垃圾收集器永远不会回收掉引用的对象。
  * 软引用（Soft Reference），软引用用来描述一些还有用但非必须的对象。对于软引用关联的对象，在将要发生内存溢出之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。Soft Reference类实现软引用。
  * 弱引用（Weak Reference），软引用用来描述非必要对象，当垃圾收集器工作时，无论当前栈内存是否足够，都会回收掉被弱引用关联的对象。WeakReference类来实现弱引用。
  * 虚引用（Phantom Reference），虚引用称为幽灵引用或幻影引用，最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生命时间构成影响，也无法通过一个虚引用来获取对象实例，唯一的目的，是在该对象被收集器回收时收到一个系统通知。PhantomReference类实现虚引用。

* 生存还是死亡

  * 即使在可达性分析算法中不可达的对象，也并不是“非死不可”，真正死亡需要经历两次标记过程。
    * 对象在经过可达性算法之后，没有发现与GC Roots相连的引用链，那么它会被第一次标记并进行筛选，筛选条件是判断该对象是否有必要执行finalize()方法。当对象没有覆盖（重写）finalize()方法或虚拟机已经执行过finalize()方法时，虚拟机视为“没有必要执行”。
    * 如果对象被判定有必要执行finalize()方法，那么该对象会被放入F-Queue队列中，稍后由虚拟机自动创建一个低优先级的Finalizer线程去执行。这里所谓的”执行“是指虚拟机会触发这个方法，但并不承诺等待执行结果，原因是如果一个对象在finalize()方法中执行缓慢，或者发生死循环，将可能到F-Queue队列一直阻塞，导致整个内存回收系统崩溃。
    * finalize()方法时对象逃离的最后机会，稍后GC将对F-Queue队列中的对象进行第二次标记，如果想要拯救自己，只要重新与引用链上的任何对象关联，这样第二次标记时会把它移除F-Queue队列（即将回收的集合）。如果该对象这个时候没有逃脱，那基本上真的被回收了。

* 回收方法区

  * Java虚拟机规范中可以不要求在方法区（Hot Spots永久区）实现垃圾收集，在方法区进行垃圾收集，效率太低。
  * 永久代的代码收集主要收集废弃常量和无用的类两种。
    * 废弃常量。如果常量池中“abc”，没有被任何引用，如果发生内存回收，而且必要的化，“abc”常量会被清除常量池。
    * 无用的类。判定相对苛刻，必须同时满足下面三个要求：
      * 该类的所有实例都被回收，也就是在堆中不存在该类的任何实例。
      * 加载该类的ClasslLoader已经被回收
      * 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
      * 虚拟机可以对满足上述三个条件的类进行回收，但仅仅是可以，并不是一定。

### 2.垃圾收集算法

* 标记-清除算法（Mark-Sweep）
  * 直接标记哪些对象需要回收，进行回收清除。
  * 特点
    * 效率低
    * 会产生内存碎片
* 复制算法（Copying）
  * 将内存划分为大小相同的两块区域，只使用其中一块。当这一块内存使用完，将还存活的对象复制到另一块空白区域，然后清除该区域对象。
  * 特点
    * 不会产生内存碎片
    * 内存利用率只有50%
* 标记-整理算法（Mark Compact）
  * 先标记出哪些对象需要回收，把被标记对象向一端移动，清理掉端边际以外的内存。
* 分代收集算法（Generational Collection）
  * 根据对象存活周期不同，讲内存划分为几块，采用不同的收集算法。新生代、老年代。
  * 新生代，每次回收会有大批对象死去，少量存活，采用复制算法。
  * 老年代，对象存活率较高，没有额外空间对它分配担保，才有标记清理或标记整理算法。

## 三、HotSpot的算法实现

### 1.枚举根节点

​	在可达性分析算法中，从GC Roots节点找到引用链为例，可作为GC Roots的节点一般为**全局引用（常量或类静态属性）或执行上线文（栈帧中的本地变量表）**，现在很多引用方法区都有数百兆，逐个检查引用，必定要消耗很多时间。

​	可达性分析算法对执行时间敏感，在执行该算法时，整个执行系统看起来像被冻结到某个时间点上，不能出现分析过程中对象引用不断变化的情况，否则无法保证分析结果的正确性。这一点是导致GC进行时必须停顿所有的Java执行线程（Stop The World）的一个重要原因，即时在号称不会发生停顿的CMS收集器中，枚举根节点也是必须要停顿的。	

​	目前主流的虚拟机都是采用准确式的GC，当执行系统停顿下来，不需要一个不漏检查完执行上下文和全局引用的位置，虚拟机应当有办法知道哪些地方存在引用。在HotSpot实现中，使用OopMap的数据结构来完成，类加载完成之后，HotSpot把对象内什么偏移量上是什么类型的数据计算出来了，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是被引用的。这样，在GC扫描的时候，只扫描被引用的位置。

### 2.安全点

​	在OopMap的协助下，JVM可以快速确定GC Roots枚举，但是存在引用关系变化，或者说OopMap内容变化的指令非常多，如果每条变化都产生一个OopMap，将会需要大量额外空间，这样GC的空间成本会很高。实际上，HotSpot没有为每条指令都生成OopMap，只是在“特定位置”记录这些信息，这些位置称为“安全点”，即程序执行的时候，只有在安全点才发生GC（程序暂停）。

​	Safepoint的选定既不能太多（频繁GC导致负荷增大），也不能太少（GC等待时间过长），所以安全点的选定的标准是“是否具有让程序长时间执行的特征”，例如方法调用，循环跳转，异常跳转等。

​	对于Safepoint，另一个需要考虑的问题是如何保证所有的线程（不包括JNI线程）都在安全点停下来，有两种方案：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）。

* 抢先式中断不需要线程的执行代码配合，在GC发生时，中断所有线程，如果发现有线程不在安全点上，恢复线程，让它执行到安全点，现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC。
* 主动中断的思想是，当GC需要中断线程时，不直接中断线程，而是设置一个标志，各个线程执行时轮询该标志，发现中断标志为真时自己主动中断挂起。轮询标志的地址和安全点重合，再加上创建对象分配内存的地方。

### 3.安全区域

​	Safepoint机制保证了程序执行时，在不太长时间就会遇到可进入GC的Safepoint。但程序不执行的时候，没有分配CPU时间，典型的例子是线程睡眠或阻塞状态，线程无法响应JVM的中断请求，无法执行到安全点中断自己，JVM也不太可能等待线程重新被分配CPU时间。这种情况，需要安全区域（Safe Region）来解决。

​	Safe Region是指在一段代码片段之中，对象引用关系不会发生变化。这个区域的任何地方都可以GC，可以把Safe Region是Safepoint的扩展。线程执行到Safe Region时，首先标志自己已经进入Safe Region，当在这段时间JVM要发起GC时，不用管标识自己为Safe Region状态的线程，在线程要离开Safe Region时，它要检查整个系统是否完成GC，如果完成，线程继续执行，否则必须等待，直到收到可以离开Safe Region的信号为止。

##  四、垃圾收集器

​	虽然我们对各个收集器进行比较，但并非挑选一个最好的收集器，因为目前为止还没有最好的收集器出现，更加没有万能的收集器，我们选择的只是对具体应用最适合的收集器。

![img](http://img-blog.csdnimg.cn/20181219110924217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzYyNzc1,size_16,color_FFFFFF,t_70) 

### 1.Serial收集器

* 最基本，历史最悠久的收集器，JDK1.3之前是新生代收集唯一的选择。
* 单线程收集器，它在垃圾收集时，必须暂停所有工作线程，直到它收集结束。
* Client模式下默认新生代收集器。

### 2.ParNew收集器

* Serial的多线程版本，单CPU下没Serial效率高，CPU增加ParNew效果明显。
* 除Serial外，只有ParNew能配合CMS的老年代收集器。

**并行（Parallel）：指多条垃圾收集线程并行执行，但是此时用户线程处于等待状态。**

**并发（Concurrent）：指用户线程和垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户线程在继续执行，而垃圾收集程序运行在另一个CPU上。**

### 3.Parallel Scavenge收集器

* 采用复制算法，并行的多线程收集器。
* 目标是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)。停顿时间越短适合需要用户交互的程序，而高吞吐量可以高效利用CPU时间，尽快完成运行任务，主要适合后台运算而不需要太多交互的任务。
* Parallel Scavenge收集器提供两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间`--XX:MaxGCPauseMillis`参数和直接设置吞吐量大小的`--XX:GCTimeRatio`参数。
* 吞吐量有限收集器，虚拟机会根据当前系统的运行情况，收集器性能监控信息，动态调整参数以提供最适合的停顿时间或最大吞吐量，这种调节方式称为GC自适应调节策略（GC Ergonomics）。

### 4.Serial Old收集器

* serial收集器老年代版本，单线程收集器，采用“标记-整理”算法。
* 主要给Client模式下老年代用。
* 如果在Server模式下，JDK1.5前与Parallel Scavenge收集器搭配使用；作为CMS收集器的备选。

### 5.Parallel Old收集器

* Parallel Scavenge收集器的老年代，多线程“标记-整理”算法。
* 配合新生代Parallel Scavenge收集器使用。

### 6.CMS收集器

* CMS收集器以获取最短回收停顿时间为目标。
* 标记-清除算法实现，分4个步骤
  * 初始标记。仅仅标记GC Roots能直接关联的对象，速度很快。时间：短
  * 并发标记。GC Roots Tracing的过程。时间：长
  * 重新标记。修正并发标记期间，被标记对象产生变化的部分。时间：中
  * 并发清除。
* 优点：并发收集，低停顿。
* 缺点：
  * 对CPU资源敏感。其实面向并发设计的程序都对CPU资源比较敏感，在并发阶段，虽然不会导致用户线程停顿，但会因此占用一部分CPU资源导致应用程序变慢，总吞吐量下降。CMS默认开启回收线程数为（CPU数量+3）/4，所消耗的资源随CPU的增加而下降。如果CPU不足4，CMS对用户程序的影响就会很大，此时虚拟机提出了“增量式并发收集器”（I-CMS）,使用抢占式来模拟多任务机制，就是在并发标记、清理的时候让GC线程和用户线程交替运行，尽量减少GC线程所独占资源的时间，这样整个GC时间会变长，对用户程序的影响就会显得少，但是下降没有很明显，所有虚拟机默认关闭，不推荐使用。
  * CMS无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理垃圾阶段，用户线程还在运行，伴随着程序的运行，会有新的垃圾不断产生，这部分垃圾在标记之后，CMS无法在当次收集中处理掉它们，这部分垃圾称为“浮动垃圾”。也是由于收集时，用户线程还在运行，，不能等到老年代几乎完成被填满时再收集，需要预留足够的内存空间给用户线程使用。JDK1.5，老年代68%后就会被激活，JDK1.6，92%，如果预留的内存不够用户程序使用，会出现“Concurrent Mode Failure”失败，这时会临时启用Serial Old收集器来重新对老年代的垃圾收集，这样停顿时间就很长了。
  * 由于CMS是采用”标记-清除“算法，所以收集结束会产生大量的内存碎片，碎片过多，会对大对象分配产生麻烦，往往老年代还有很多空间，但是无法找到足够连续的内存分配当前对象，不得不触发一次Full GC。解决方式：CMS收集器提供了一个`--XX:+UseCMSCompactAtFullCollection`开关的参数，默认开启，用于在CMS顶不住要进行Full GC时开启内存合并整理过程，但是内存整理过程无法并发进行，会导致停顿时间变长。此时虚拟机提供`--XX:CMSFullGCsBeforeCompaction`参数来设置执行多少次不压缩的Full GC后，跟着来一次压缩操作（默认为0，表示每次Full GC时都进行碎片整理）。

### 7.G1收集器

* G1（Garbage-First）收集器是当今收集器技术发展最前沿技术之一。
* G1是一款面向服务端应用的垃圾收集器，未来可以替换CMS收集器。
* 特点：
  * 并行与并发：G1能充分利用多CPU、多核环境下硬件资源。Java执行GC动作，G1收集器仍能通过并发的方式让Java程序继续运行。
  * 分代收集：虽然可以不依赖其他收集器独立管理整个GC堆，但它能采用不同的方式去处理新创建的对象和已经存活一段时间、熬过多次GC的旧对象以获取更好的收集效果。
  * 空间整合：整体基于“标记-整理”算法，局部（两个Region）采用“复制”算法。
  * 可预测停顿时间：减低停顿时间是CMS和G1共同关注点，但G1除了追求停顿外，会建立可预测的停顿时间模型，能让使用者明确指定在一个长度为Mms的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎是实时Java（RTSJ）的收集器特征了。
* 使用G1收集器时，Java堆的内存布局就与其他收集器有很大区别，它将堆分为多个大小相等的独立区域（Region），虽然还保留了新生代和老年代的概念，但是新生代和老年代不在隔离，他们都是一部分Region（不需要连续）的集合。
* G1收集器之所以能建立可预测的停顿时间模型，是因为它有计划的避免在整个Java堆中进行全区域的垃圾收集。G1会跟踪各个Region里面的垃圾堆积的价值（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这就是Garbage-First的由来）。
* Region不是独立的，存在不同Region对象的相互引用，在判断对象是否存活的可达性分析算法中如何避免全区域扫描。

### 8.GC日志

### 9.垃圾收集器参数总结

| 参数                           | 描述                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| UseSerialGC                    | 虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial + Serial Old的收集器组合进行内存回收 |
| UseParNewGC                    | 打开此开关后，使用ParNew + Serial Old的收集器组合进行内存回收 |
| UseConcMarkSweepGC             | 打开此开关后，使用ParNew+ CMS + Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用 |
| UseParallelGC                  | 虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old (PS Mark Sweep)的收集器组合进行内存回收 |
| UserParallelOldGC              | 打开此开关后，使用Parallel Scavenge + Parallel Old的收集器组合进行内存回收 |
| SurvivorRatio                  | 新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden: Survivor = 8:1 |
| PretenureSizeThreshold         | 直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配 |
| MaxTenuringThreshold           | 晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄就增加1，当超过这个参数值时就进入老年代 |
| UseAdaptiveSizePolicy          | 动态调整Java堆中各个区域的大小以及进入老年代的年龄           |
| HandlePromotionFailure         | 是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况 |
| ParallelGCThreads              | 设置并行GC时进行内存回收的线程数                             |
| GCTimeRatio                    | GC时间占总时间的比率，默认值是99， 即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效 |
| MaxGCPauseMillis               | 设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效  |
| CMSInitiatingOccupancyFraction | 设置CMS收集器在老年代时间被使用多少后触发垃圾收集。默认值为68%，仅在使用CMS收集器时生效 |
| UseCMSCompactAtFullCollection  | 设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效 |
| CMSFullGCsBeforeCompaction     | 设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理，仅在使用CMS收集器时生效 |

## 五、内存分配与回收策略

​	Java技术体系所提倡的自动内存管理最终是要解决两个问题，一个是垃圾回收，一个是内存分配。

​	对象的内存分配，从大方向上讲，就是在堆上分配（可能经过JIT编译后被拆散为标量类型并间接的栈上分配），对象（普通新对象）主要分配在新生代Eden区，如果启动了本地线程缓存，将按线程优先在TLAB上分配。部分对象（大对象）也可能直接分配在老年代，分配规则并不是百分百确定的，取决于当前使用的垃圾收集器组合和虚拟机内存参数。

### 1.对象优先在Eden上分配

- 大多数情况下，对象在新生代Eden区域分配，当Eden没有足够空间进行分配时，虚拟机发起一次Minor GC。
- 虚拟机提供`-XX:+PrintGCDetails`这个收集器日志参数，告诉虚拟机在发生垃圾收集时打印内存回收日志，并且在进程退出时输出当前内存分配各区域情况。
- 新生代GC（Minor GC）:指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。
- 老年代（Major GC/Full GC）：放生在老年代的GC，每次Major GC经常会伴随至少一次Minor GC（不是绝对，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略）。Major GC的速度一般比Minor GC慢10倍以上。

### 2.大对象直接进入老年代

- 大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串或者数组。大对象对虚拟机的内存分配是个坏消息（比存在大对象更糟糕的是大对象的使用周期很短），经常出现大对象容易造成还有很多内存空间时就提前触发垃圾收集来获取足够连续的空间来存放它们。
- 虚拟机提供参数`-XX:PretenureSizeThreshold`（只对Serial和ParNew两款收集器有效）来确定是否为大对象，如果超过该值，直接在老年代分配。这样避免在Eden区已经两个Survivo区之间发生大量的内存复制。

### 3.长期存活的对象将进入老年代

- 虚拟机采用分代收集的策略，那么它就需要知道哪些对象应放什么区域（新生代、老年代）。为了做的这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。
- 如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且能被Survivor容纳，那么它将被移动到Survivor空间中，并且对象年龄设为1。对在Survivor空间中，每熬过一次Minor GC，age都会加1，当age增加到一定程度（默认为15岁），将会被晋升到老年代。可以通过`-XX:MaxTenuringThreshold`参数来设置年龄阈值。

### 4.动态年龄判断

​	为了更好的适应不同程序的内存情况，虚拟机并不是永远地要求对象的年龄必须达到设定的年龄阈值才能晋升老年代，如果Survivor空间中相同年龄所有对象的总和大于Survivor空间的一半，年龄大于或等于该相同年龄的对象就会直接进入老年代，无需等到设定的年龄阈值。

### 5.空间分配担保

​	在放生Minor GC之前，虚拟机总会检查老年代最大可用连续的内存是否大于新生代所有对象的总空间，如果成立，则确保该次Minor GC是安全的。如果不成立，虚拟机会查看`HandlePromotionFailure`设置的值是否允许担保失败。如果允许，那么继续检查老年代最大可以连续内存是否大于历次晋升老年代对象的平均值，如果大于，尝试一次Minor GC，尽管这次GC存在风险。如果小于，或者设置的`HandlePromotionFailure`不允许冒险，这时要进行一次Full GC。

## 六、字节码

### 1.Class类文件数据结构

​	Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在Class文件中，中间没有任何分隔符，这使得Class文件中的内容都是程序运行的必要数据。当需要8位字节以上空间的数据项时，则会按照高位在前（Big-Endian）的方式分割成若干个8位字节存储。Big-Endian具体指的是最高位字节在地址最低位、最低位字节在地址最高位的顺序来存储。

根据Java虚拟机规范，Class文件格式采用伪结构来存储数据，只有两种数据类型：无符号数和表。

- 无符号数属于基本数据类型，以u1,u2,u4,u8来分别代表1个字节，2个字节，4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符串值。
- 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有的表都习惯性以“_info”结尾。表用于描述有层次关系的复合结构数据，整个Class文件本质上是一张表。
- 无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，会使用一个前置的容器计数器加若干连续的数据项形式，这是称这一系列连续的某一类型的数据为某一类型的集合。

#### 魔数

* 每个Class文件的前4个字节称为魔数，它的唯一作用是确定这个Class文件是否为能被虚拟机接受的Class文件。很多文件存储标准中都使用魔数来进行身份识别，譬如gif，jpeg等文件头中都有魔数。使用魔数而不是扩展名来进行识别，主要是基于安全方面的考虑，因为扩展名可以随意改动。

* Class文件的开始的魔数为0xCAFEBABE（咖啡宝贝），紧接着的4个字节的魔数是Class文件的版本号：第5个和第6个字节是次版本号，第7个和第8个字节是主版本号。Java的版本号是从45开始的，JDK1.1之后的每个JDK大版本发布主版本号向上加1，高版本的JDK能向下兼容以前版本的Class文件，但不能运行更高版本的Class文件，即使文件格式没有发生任何变化，虚拟机也不能执行超过当前JDK版本的Class文件。

#### 常量池

* 紧接着主版本号的是常量池入口，常量池可以理解为Class文件的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时也是Class文件中第一个出现表类型数据的项目。
* 由于常量池中常量的数量是不固定的，所以常量池的入口需要放置一项u2（2个字节）类型的数据，代表常量池容量计数值，这个容量值是从1开始的。常量池容量（偏移地址：0x00000008）为16进制数的0x0016，即十进制的22，这代表常量池中有21个常量，索引范围为1~21。在Class文件规范制定时，设计者将第0项常量空出来是为了满足，后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这时索引值置为0。
* Class文件只有常量池的索引从1开始（0表示不引用任何常量池），对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都是从0开始。
* 常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic Reference）。字面量比较接近Java语言层面的常量概念，如文本字符串、声明为final的常量值等。符号引用则是属于编译原理方面的概念，包括下面三类常量：
  * 类和接口的全限定名
  * 字段的名称和描述符
  * 方法的名称和描述符
* Java代码在Javac编译的时候，不会像C++有“连接”的动作，而在虚拟机加载Class文件的时候进行动态连接。也就是说，在Class文件中并不会保存各个方法、字段的最终内存信息，因此这些字段、方法的符号引用在不经过运行期转换的话无法得到程序的真正的内存入口地址，也无法直接被虚拟机使用。在虚拟机运行时，需要从常量池中获取对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中。
* 常量池中每一项常量都是一个表，JDK7之前有11种结构各不相同的表结构数据，JDK1.7中为了更好地支持动态语言调用，额外增加三种。这14种表结构开始的第一位都是u1类型的标志位，代表当前这个常量属于哪种常量类型。
* Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，CONSTANT_Utf8_info的最大长度就是Java中方法、字段名的最大长度，即u2类型能表达的最大值65535，所以Java程序如果定义了超过64KB英文字符的变量或变量名，将无法编译。

#### 访问标志

* 常量池结束之后，紧接的两个字节表示访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括Class是类还是接口；是否定义为public类型；是否定义为abstract类型。如果是类，是否被声明为final等。

  ![img](http://ww1.sinaimg.cn/large/af7d73dftw1erdhzuodpvj20wu0dqgq3.jpg) 

* access_flags中一共有16个标志位可以使用，当前只定义了其中8个，没有使用到的标志位要求一律为0。

#### 父索引，父类索引与接口索引集合

​	类索引和父类索引都是u2类型的数据，而接口索引集合是一组u2类型的数据集合，Class文件中由这三项数据确定继承关系。类索引用于确定该类的全限定名，父类索引确定这个类的父类的全限定名。由于Java不能多继承，所以父类索引只有一个，除Object类外，任何类的父类索引不为0。接口索引集合就是用来描述这个类实现了哪些接口，这些被实现的接口将按照实现顺序依次排列在接口索引集合中。如果类本身是一个接口，则是被继承接口。

#### 字段表集合

​	字段表（field_info）用于描述接口或类中定义的变量。字段包含类级变量和实例级变量，但不包含方法中声明的局部变量。

​	Java中描述一个字段可以包含的信息：字段作用域、实例变量还是类变量、可变性、并发可见性、是否被序列化（transient修饰符）、字段数据类型、字段名称。而字段叫什么名称、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。

#### 方法表集合

​	Class文件中对方法的描述与字段的描述一样，方法表的结构如同字段表一样，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attribute）几项。

#### 属性表集合

​	与其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松些，不再要求各属性表具有严格的顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。

1. Code属性

   * Java程序方法体中的代码经过javac编译器处理后，最终变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合中，但并非所有的方法表中都包含Code属性，如接口或抽象类中的方法就不存在Code属性（JDK8存在默认函数）。
   * Code属性是Class文件中最重要的一个属性，如果把Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么整个Class文件中，Code属性用于描述代码，所有其他数据项目都是描述元数据。

2. Exceptions属性

   ​	Exceptions属性与Code属性在方法表中同一级，不是异常表。Exceptions属性的作用是列举出方法中可能抛出的受检查异常（Check Exception），也就是方法描述时在throws关键字后面列举的异常。

3. LineNumberTable属性

   ​	用于描述Java源码行号与字节码行号（字节码的偏移量）之间的关系。它并不是运行时必须的属性，但默认会生成到Class文件中，可以在javac中分别使用`-g:none`或`-g:lines`选项来取消或要求生成这项信息。如果选择不生成，对程序最主要的影响是当抛出异常时，堆栈中将不会显示出错行号，并且在调试程序时，也无法按照源码行设置断点。

4. LocalVariableTable属性

   ​	用于描述栈帧中局部变量表中的变量与Java源码中定义的变量的关系，它也不是必须的，但默认会生成到Class文件中。可以在javac中使用`-g:none`或`-g:vars`来取消或生成。如果没有该项信息，当其他人引用这个方法时，所有的参数名称都将会丢失，IDE会使用诸如arg0,arg1之类的占位符来代替原有的参数名，这对程序没有影响，会对代码编写带来很大的不便，而且在调试期间无法根据参数名称获取参数值。

5. SourceFile属性

   * 记录生成这个Class文件的源码文件名称。
   * 可选，`-g:none`或`-g:source`来取消或生成。
   * Java中对大多数类，类名和文件名一致（内部类例外）。
   * 如果不生成这个属性，当抛出异常时，堆栈信息不会显示出错代码文件名。
   * 定长属性。

6. ConstantValue属性

   * 作用是通知虚拟机自动为静态变量赋值。
   * 只有被static修饰的变量才能使用这个属性。
   * 只限于基本属性和String。
   * 定长属性。

7. InnerClasses属性

   * 记录内部类和宿主类之间的关联。
   * inner_name_index指向常量池中CONSTANT_Utf8_info型常量的索引，代表内部类的名称，如果是匿名内部类，值为1。

8. Deprecated及Synthetic属性

   * 都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。
   * Deprecated属性用于表示某个类、方法或字段，已被作者定为不推荐使用，可以在代码中通过`@deprecated`注释进行设置。
   * Synthetic属性代表此字段或方法并不是有Java源码直接产生的，而是由编译器自行添加的。

9. StackMapTable属性

   * JDK1.6后增加到Class文件规范中，复杂的变长属性，位于Code属性的属性表中。
   * 会在虚拟机类加载的字节码验证阶段被新类型检查验证器（Type Checker）使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。

10. Signature属性

   * JDK1.5后增加到Class文件规范中，可选定长属性，出现在类、属性表和方法表结构的属性表中。
   * 记录泛型签名信息，Java语言采用的是擦除法实现的伪泛型，在字节码（Code属性）中，泛型信息编译（类型变量，参数化类型）之后，都会被统统擦除。

11. BootstrapMethod属性

    * JDK1.7增加到Class规范中，复杂的变长属性，位于类文件的属性表中。
    * 用于保存invokedynamic指令引用的引导方法限定符。

### 2. 字节码指令简介

​	Java虚拟机的指令是有一个字节长度的，代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟其后的零至多个代表此操作所需参数（操作数，Operands）而构成。由于虚拟机采用的面向操作数栈帧而不是寄存器的架构，所以大多数的指令都不含操作数，只有操作码。

​	字节码指令集是一种具有鲜明特点、优劣势都很突出的指令集架构，由于限制了Java虚拟机操作码的长度为一个字节（即0~255），这意味着指令集的操作码总数不能超过256条；由由于Class文件放弃了编译后代码的操作数长度对齐，这就意味着虚拟机处理那些超过一个字节数据时，不得不在运行时从字节中重建出具体的数据结构。这样做会导致解释执行字节码时损失一些性能，但优势也很明显，放弃了操作数长度对齐，意味着可以省略很多填充和间隔符号。用一个字节来代表操作码，也是为了尽可能获得短小精干的编译代码。

#### 字节码与数据类型

* Java虚拟机指令集中，大多数指令都包含其操作所对应的数据类型信息。如，iload指令用于从局部变量表中加载int类型的数据到操作数栈中，fload加载float类型的数据。这两条指令的操作在虚拟机内部可能是有一段代码实现，但在Class文件中它们必须拥有各自独立的操作码。

#### 加载和存储指令

* 加载和存储指令，用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，内容如下：
  * 将一个局部变量加载到操作数栈：iload、iload_<n>、lload等。
  * 将一个数值从操作数栈存储到局部变量表中：istore、istore_<n>、lstore等。
  * 将常量加载到操作数栈：bipush、sipush、ldc等。
  * 扩展局部变量表的访问索引的指令：wide。
* 存储数据的操作数栈和局部变量表主要就是由加载和存储指令进行操作，除此之外还有少量指令，如访问对象的字段或数组元素的指令也会向操作数栈传输数据。
* iload_<n>这些指令实际上代表一组指令(iload_0,iload_1)。

#### 运算指令

* 运算和算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入操作数栈顶。
* 算术指令分为两种：整数运算和浮点运算。

#### 类型转换指令

* 类型转换指令可以将两个不同类型数据进行相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作。
* Java虚拟机直接支持宽化类型转换，即小范围型向大范围型的安全转换，相对的窄化型转换必须显式使用转换指令来完成。窄化型转换可能导致转换结果产生不同的正负号、不同的数量级、精度丢失等问题。

#### 对象创建和访问指令

* 虽然类实例和数组都是对象，但是Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令（数组和不同实例的创建过程不同）。对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的元素。

#### 操作数栈管理指令

* 如同操作普通数据结构中的堆栈一样，Java虚拟机提供了直接操作操作数栈的指令。如;
  * 将操作数栈的栈顶一个或两个元素出栈：pop、pop2
  * 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1
  * 将栈顶两个数值互换：swap

#### 控制转移动指令

* 控制转移指令可以让Java虚拟机有条件或无条件地从指定的位置指令继续执行程序（而不是控制转移指令的下一条指令），从模型上理解，可以认为控制转移指令就是在有条件或无条件的修改PC寄存器的值。
* 在虚拟机中有专门的指令集来处理int和reference类型的条件判断操作，为了可以无须显式标识一个实体值是否为null，也有专门的指令检测null值。

#### 方法调用和返回指令

* invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。
* invokeinterface指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出合适的方法进行调用。
* invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。
* invokestatic用于调用类方法（static修饰的方法）
* invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，前面4条指令的分配逻辑都固化在Java虚拟机内部，而invokedynamic指令的分配逻辑是由用户所设定的引导方法决定的。
* 方法调用方法与数据类型无关，而返回指令是根据方法返回值类型区分的。

#### 异常处理指令

* 在Java程序中显式抛出异常的操作（throw语句）都是由athrow指令完成的。
* 运行时异常会在其他Java虚拟机指令检测到异常状况自动抛出。
* Java虚拟机，处理异常不是由字节码指令来实现的，而是采用异常表来完成。

#### 同步指令

* Java虚拟机支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管称（Monitor）来支持的。
* 方法级的同步是隐式的，即无需通过字节码指令来控制，它的实现在方法调用和返回操作之中。
* 虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED的访问标志得知一个方法是否声明为同步方法，方法调用时将检查ACC_SYNCHRONIZED标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论正常完成还是非正常完成），释放管程。在方法执行期间，执行线程持有管程，其他任何线程都无法获取同一个管程。如果同步方法执行期间抛出异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的管程将在异常抛出到同步方法之外时自动释放。
* 同步一段指令集序列通常是有Java语言的synchronized语句块来表示，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持，正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持。
* 编译器必须确保无论方法通过何种方式完成，方法中调用的每条monitorenter指令都必须执行对应的monitorexit指令，无论这个方法是正常结束还是异常结束。
* 为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理的所有异常，它的目的就是用来执行monitorexit指令。

![åæ­¥ä»£ç å­èç åæ.png](https://github.com/gnng/bookList/blob/master/image/%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90.png?raw=true) 

### 3.共有设计和私有实现

* Java虚拟机规范描绘了Java虚拟机应有的共同程序存储格式Class文件格式以及字节码指令集。这些内容与硬件、操作系统及具体的Java虚拟机实现之间是完全独立的，虚拟机实现者可能更愿意把它们看做是程序在各种Java虚拟机实现之间相互安全转换的手段。
* Java虚拟机实现必须能够读取Class文件并精确实现包含在其中的Java虚拟机代码的语义。拿着Java虚拟机规范一成不变地逐字实现其中要求的内容当然是可行的，但是一个优秀的虚拟机实现，在满足虚拟机规范的约束下对具体实现做出修改和优化也是可行的，只要优化后的Class文件可以被正确读取。
* 虚拟机实现者可以使用这种伸缩性让Java虚拟机获得更高的性能、更低的内存消耗或者更好的可移植性，选择哪种特性取决于Java虚拟机实现的目标和关注点。虚拟机实现主要有两种方式：
  * 将输入的Java虚拟机代码在加载或执行时翻译成另一种虚拟机的指令集。
  * 将输入的Java虚拟机代码在加载或执行时翻译成宿主机CPU的本地指令集（JIT代码生成技术）。

## 七、虚拟机类加载机制

### 1. 概述

​	虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机直接使用的Java类型，这就是虚拟机类加载机制。

​	与那些编译时需要进行连接的语言不同，在Java语言里面，类的加载、连接和初始化的过程都是在程序运行期间完成的，这种策略虽然会使类加载时消耗一些性能，但为Java程序提供了高度的灵活性，Java可以动态扩展的语言特性就是依赖运行期动态加载和动态连接实现的。例如，编写一个面向接口的应用程序，可以等到运行时再指定具体的实现类；用户可以通过Java预定义的和自定义类加载器，让一个本地的应用程序在运行时可以从网上或其他地方加载一个二进制流作为程序代码的一部分。

### 2. 类加载时机

* 类从被加载到内存中开始，到卸载出内存为止，它的整个生命周期为：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段。其中验证、准备、解析3个部分统称为连接（Linking）。
* 加载、验证、准备、初始化和卸载这5个阶段的顺序是固定的，类的加载必须按整个顺序按部就班地开始，而解析阶段不一定：在某些情况下可以在初始化之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。这些阶段通常都是相互交叉地混合进行的，通常会在一个阶段执行过程中调用、激活另一个阶段。
*  对于**初始化阶段** ，虚拟机规范严格规定了有且只有5种情况必须对类进行初始化（加载、验证、准备需要在此之前开始）：
  * 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行初始化，则需要先触发其初始化。最常见的场景是使用new关键字实例化对象时候、读取或设置一个类的静态字段（被final修饰、已在编译期已把结果放入常量池的静态字段除外），以及调用一个类的静态方法的时候。
  * 使用`java.lang.reflect`包的方法对类进行反射调用的时候，如果类没有进行初始化，需要先进行初始化。
  * 当初始化一个类的时候，发现其父类没有初始化，则要先初始化其父类。
  * 当虚拟机启动时，用户需要指定一个要执行的主类（包含`main()`方法的那个类），虚拟机会先初始化这个类。
  * 当使用JDK1.7的动态语言支持时，如果一个`java.lang.invoke.MethodHandle`实例最后的解析结果`REF_getstatic`、`REF_putstatic`、`REF_invokestatic`的方法句柄时，并且这个方法句柄所对应的类没有初始化过，则需要先触发其初始化。
* 对于这5中，虚拟机规范中强烈限定“有且仅有”，这5中场景的行为称为对一个类的主动引用，除此之外，所有引用类的方式都不会触发初始化，称为被动引用。

### 3. 类加载的过程

#### 加载

* 加载是类加载过程中的一个阶段，在加载阶段虚拟机会完成一下3件事：

  * 通过一个类的全限定名来获取定义此类的二进制字节流。

    * 虚拟机没有明确指定二进制流要从一个Class文件中获取，准确说根本没有指明二进制文件来源。所以可以从以下几种方式中读取二进制流：

      * 从ZIP包中读取，最终成为JAR、EAR、WAR格式的基础。

      * 从网络中获取，最常见的就是Applet。

      * 运行时计算生成，这种场景使用最多的就是动态代理技术，在`java.lang.reflect.Proxy`就是用`ProxyGenerator.generateProxyClass`类来为特定接口生成形式为“*Proxy”的代理类的二进制字节流。

      * 由其他文件生产，典型场景JSP，即JSP文件生成对应的Class类。

      * 从数据库中读取，使用场景较少，可以选择把程序安装到数据库中来完成程序代码在集群中的分发

        ......

  * 将字节流所代表的静态存储结构转化为方法区的运行时数据结构。

  * 在内存上生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据访问入口。

### 4. 类加载器
# 《深入理解Java虚拟机》读书笔记

[TOC]

## 一、自动内存管理机制

### 1. Java内存区域

* 程序计数器
  * **较小**的一块内存**空间**，可以看做是**当前线程**执行的字节码的**行号指示器**。**字节码解释器工作时就是通过改变这个计数器的值来取下一条需要执行的字节码指令**，分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。
  * 如果线程正在执行的是Java方法，计数器存储的是当前执行字节码指令地址；如果执行的本地方法（Native），这个计数器值为空（Undefined）。
  * 此区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
* Java虚拟机栈
  * 线程私有，生命周期与线程相同。
  * 描述Java方法执行的内存模型，每个方法执行的时候都会创建一个**栈帧**，用于存储**局部变量表、操作数栈、动态链接、方法出入口**等信息。每一个方法从调用到执行完成都对应一个栈帧在虚拟机栈中从入栈到出栈的过程。
  * 局部变量表存放的是编译期可知的基本数据类型（3类8种），对象引用类型。
  * 64位长度的long和double类型的数据占2个局部变量空间（slot）,其余的数据类型占1个。
  * 此区域规定了两种异常状况：如果线程请求栈深度大于虚拟机所允许栈深度，抛出StackOverFlowError异常；如果虚拟机栈可以动态扩展（当前大部分Java虚拟机都可动态扩展），如果扩展时无法申请到足够内存，抛出OutOfMemoryError异常。
* 本地方法栈
  * 与虚拟机栈类似，区别是Java虚拟机栈执行的是Java方法（字节码），本地方法栈执行的是本地方法（Native修饰的方法）。
  * 有的虚拟机讲本地方法栈和虚拟机栈合二为一。
  * 本地方法栈也会抛出StackOverFlowError和OutOfMemoryError异常。
* Java堆
  * Java虚拟机所管理的内存中最大的一块区域，被**所有线程共享**，在虚拟机启动时创建。
  * 唯一目的，存入Java对象实例。分配大部分实例（JIT编译器的发展与逃逸分析技术的成熟，栈上分配、标量替换优化技术）。
  * Java堆是垃圾收集器管理的主要区域。
    * 从内存回收的角度，由于现在收集器基本都是采用分代收集算法，所以Java堆还可以细分为：新生代和老年代，再细分Eden空间、From Survivor空间和To Survivor空间等；
    * 从内存分配角度，线程共享的Java堆中可能划分出多个**线程私有的分配缓冲区（Thread Loacl Allocation Buffer TLAB）**;
  * 根据Java虚拟机规范，Java堆可以处理物理上不连续的内存空间，只要逻辑上连续即可，类似于磁盘空间。在实现时，既可以固定大小，也可以动态扩展（通过-Xmx和-Xms控制）。
* 方法区
  * **所有线程共享**，存储被虚拟机加载的**类信息、常量、静态变量、即时编译器编译后的代码**等数据。
* 运行时常量池
  * 运行时常量池是方法区的一部分。
  * Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池。
  * 可能抛出OutOfMemoryError异常。
* 直接内存
  * 直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是**被频繁使用**。
  * JDK1.4引入的NIO（new input/output）类，引入了一种基于管道和缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的`DirectByteBuffer`对象作为这块内存的引用进行操作（避免Java堆和Native堆来回复制数据）。

### 2. 对象管理

* 对象的创建
  * 检测是否被加载过。当虚拟机遇到一条new指令时，首先检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用对应的类是否已被加载、解析和初始化。如果没有，先执行类加载过程。
  * 对象内存分配。类加载检查通过后，虚拟机会新生对象分配内存。对象所需内存大小在类加载完成后便可完全确定，为对象分配内存的过程相当于在Java堆中为对象划出一块大小确定的区域。
    * 堆内存规整，所有用过的内存在一边，另一边是空闲内存，中间存放一个指针作为分界点的指示器，所分配内存就是把指针向空闲区域移动一段对象大小相等的区域，称为“指针碰撞”。
    * 堆内存不规整，已使用的内存和空闲内存相互交错，没办法简单的指针碰撞，虚拟机必须维护一个列表，记录哪块内存可用，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。
    * 哪种方式分配取决于堆内存是否规整，堆是否规整又取决于所采用的垃圾回收器是否带有压缩整理功能。因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的收集算法是指针碰撞；而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。
  * 分配过程中的问题，指针的分配是线程不安全的。除了要考虑可用空间的划分之外，还需要考虑对象创建在虚拟机中是否为非常频繁的行为。即使仅仅修改一个指针所指向的位置，在并发情况下也不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针分配了内存。解决该问题有两种方案：
    * 分配内存空间的动作进行同步处理——实际上虚拟机采用的是CAS加上失败后重试的方式保证更新操作的原子性。
    * 把内存的分配动作按线程划分到不同空间中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Loacl Allocation Buffer,TLAB）。哪个线程要分配内存就在哪个线程的TLAB上分配，只有TLAB用完并且要分配新的TLAB时，才需要同步操作。虚拟机设置是否使用TLAB,可以通过参数-XX:+/-UseTLAB参数来设定。
  * 内存初始化，不包含对象头。内存分配完成之后，虚拟机需要将分配的内存初始化为零值（不包含对象头），如果使用TLAB，这一操作可以提前至TLAB分配时进行。这一操作，保证了对象的实例字段在java代码中不赋初始值也可以直接使用，程序能访问这些字段的数据类型所对应的零值。
  * 设置对象头。设置该对象属于哪个类、如何才能找到类的元数据信息（描述程序过程的数据）、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象头中（Object Header）。根据虚拟机当前运行状态不同，如是否启用偏向锁等，对象头会有不同的设置方式。
  * Java程序角度初始化。在虚拟机的角度，新的对象已经产生，但是从Java程序的角度来看，对象的创建才刚刚开始——还没有执行<init>方法，所有的字段都为零。一般来说，执行完new指令后会接着执行init方法，把对象按照程序员的意愿进行初始化，这样真正可用的对象才算完全创建出来。

* 对象的布局

  在HotSpot虚拟机中，对象的内存布局分为三个区域，对象头（Header）、实例数据（Instance data）和对齐填充（Padding）。

  * 对象头包含两部分：
    * 第一部分储存对象自身运行时的数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据长度32bit/64bit(32位/64位操作系统)，官方称为“Mark Word”。对象需要存储的运行时数据会很多，远远超过32位或64位bitmap结构所能记录的限度，所以为考虑虚拟机空间效率，Mark Word设计为非固定的数据结构，以便在极小的空间内存存储尽量多的信息。
    * 另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机可以通过这个指针确定该对象所有哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保存类型指针，换句话说，查找对象的元数据信息不一定要通过对象本身。
    * 如果对象是一个数组，那么对象头中必须有一块用于记录数组长度的数据。因为虚拟机可以通过普通对象的元数据信息知道对象的大小，而数组的元数据中不能确定数组的大小。
  * 实例数据。实例数据是对象真正存储的有效信息，也是程序代码中定义的各种类型字段的内容。无论是从父类继承下来，还是子类中定义的，都要记录下来。这部分存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义的顺序影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers）,从分配策略可以看出相同宽度的字段总是被分配在一起。在满足这个前提下，父类中定义的变量会出现在子类之前，如果CompactFields参数为true（默认为true）,子类中较窄的变量也可能插入到父类变量的空隙中。
  * 对齐填充。该部分并不是必然存在，也没有特别含义，仅起到占位符的作用。由于HotSpot VM的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，也就是对象的大小必须是8字节的整数倍，而对象头的大小正好是8字节的整数倍（1倍或2倍），因此当对象实例数据部分没有对齐时，就需要对齐填充来补全。

* 对象的使用。建立对象是为了使用对象，Java程序需要通过栈上的reference数据来操作堆上的具体对象。有用reference类型在虚拟机规范中只规定了一个对象的引用，并没有定义这个引入应该通过何种方式，访问堆中对象的具体地址，所以对象访问方式由虚拟机实现决定。目前主流采用句柄和直接引用两种。

  * 句柄。如果使用句柄访问，在Java堆中会划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中又包含了对象的实例数据（堆）和类型数据（方法区）各自的具体地址信息。

    ![img](http://img.mp.itc.cn/upload/20170604/34a8538fdca241568261997fb1742bcb_th.jpg) 

    

  * 直接引用。堆对象的布局得考虑类型数据的如何放置，栈中直接存储的是对象在堆中的具体地址。

    ![img](http://www.cnblogs.com/images/cnblogs_com/gscq073240/1061819/o_%e9%80%9a%e8%bf%87%e7%9b%b4%e6%8e%a5%e6%8c%87%e9%92%88%e8%ae%bf%e9%97%ae%e5%af%b9%e8%b1%a1.png) 

  * 总结。直接访问最大的好处就是速度快，节省了一次指针定位的时间开销，由于对象的访问是非常频繁的，累计出来的节省开销就非常可观，Sun HotSpot虚拟机采用的是直接访问。

### 3.内存溢出

  * 堆OOM
    * 对象数量超过最大堆容量限制
    * 定位内存泄露和内存溢出
  * 栈和本地方法栈
    * 线程请求栈的深度超过虚拟机所允许的最大深度。（stack overflow error）
    * 虚拟机在扩展时无法申请到足够多的内存空间。（OOM）
  * 方法区和运行时常量池
  * 本地直接内存溢出

## 二、垃圾收集器和内存分配策略

### 1.对象已死?

* 对象是否存活
  * 引用计数算法
    * 给对象中添加一个引用计数器，每当有一个地方引用它，计数器加1；引用失效，计数器减1。任何时刻计数器为0，表示该对象没有被使用。

    * 无法解决循环引用问题。虚拟机不是通过引用计数算法判断对象是否存活的。

      ![img](http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/YUYc62VIvE2xHo4wJUED2bXDvGMrEC5ftstZPicT32mabz2O1Y9GFpib3dUgpKL3oyJQe1tQBIwNHxGCv1rYeNbA/640?wx_fmt=png) 

  * 可达性分析算法

    * 通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）,当一个对象到GC Roots没有任何引用链相连，则证明该对象是不可用的。
    * 在Java语言中，可作为GC Roots对象包括以下几种：
      * 虚拟机栈（栈帧中的本地变量表）中引用的对象。
      * 方法区中类静态属性所引用的对象。
      * 方法区中常量引用的对象。
      * 本地方法栈中JNI（Native方法）引用的对象。

* 引用

  * 强引用（Strong Reference），强引用在程序中经常出现，如new关键字创建对象时引用，只要强引用还在，垃圾收集器永远不会回收掉引用的对象。
  * 软引用（Soft Reference），软引用用来描述一些还有用但非必须的对象。对于软引用关联的对象，在将要发生内存溢出之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。Soft Reference类实现软引用。
  * 弱引用（Weak Reference），软引用用来描述非必要对象，当垃圾收集器工作时，无论当前栈内存是否足够，都会回收掉被弱引用关联的对象。WeakReference类来实现弱引用。
  * 虚引用（Phantom Reference），虚引用称为幽灵引用或幻影引用，最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生命时间构成影响，也无法通过一个虚引用来获取对象实例，唯一的目的，是在该对象被收集器回收时收到一个系统通知。PhantomReference类实现虚引用。

* 生存还是死亡

  * 即使在可达性分析算法中不可达的对象，也并不是“非死不可”，真正死亡需要经历两次标记过程。
    * 对象在经过可达性算法之后，没有发现与GC Roots相连的引用链，那么它会被第一次标记并进行筛选，筛选条件是判断该对象是否有必要执行finalize()方法。当对象没有覆盖（重写）finalize()方法或虚拟机已经执行过finalize()方法时，虚拟机视为“没有必要执行”。
    * 如果对象被判定有必要执行finalize()方法，那么该对象会被放入F-Queue队列中，稍后由虚拟机自动创建一个低优先级的Finalizer线程去执行。这里所谓的”执行“是指虚拟机会触发这个方法，但并不承诺等待执行结果，原因是如果一个对象在finalize()方法中执行缓慢，或者发生死循环，将可能到F-Queue队列一直阻塞，导致整个内存回收系统崩溃。
    * finalize()方法时对象逃离的最后机会，稍后GC将对F-Queue队列中的对象进行第二次标记，如果想要拯救自己，只要重新与引用链上的任何对象关联，这样第二次标记时会把它移除F-Queue队列（即将回收的集合）。如果该对象这个时候没有逃脱，那基本上真的被回收了。

* 回收方法区

  * Java虚拟机规范中可以不要求在方法区（Hot Spots永久区）实现垃圾收集，在方法区进行垃圾收集，效率太低。
  * 永久代的代码收集主要收集废弃常量和无用的类两种。
    * 废弃常量。如果常量池中“abc”，没有被任何引用，如果发生内存回收，而且必要的化，“abc”常量会被清除常量池。
    * 无用的类。判定相对苛刻，必须同时满足下面三个要求：
      * 该类的所有实例都被回收，也就是在堆中不存在该类的任何实例。
      * 加载该类的ClasslLoader已经被回收
      * 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
      * 虚拟机可以对满足上述三个条件的类进行回收，但仅仅是可以，并不是一定。

### 2.垃圾收集算法

* 标记-清除算法（Mark-Sweep）
  * 直接标记哪些对象需要回收，进行回收清除。
  * 特点
    * 效率低
    * 会产生内存碎片
* 复制算法（Copying）
  * 将内存划分为大小相同的两块区域，只使用其中一块。当这一块内存使用完，将还存活的对象复制到另一块空白区域，然后清除该区域对象。
  * 特点
    * 不会产生内存碎片
    * 内存利用率只有50%
* 标记-整理算法（Mark Compact）
  * 先标记出哪些对象需要回收，把被标记对象向一端移动，清理掉端边际以外的内存。
* 分代收集算法（Generational Collection）
  * 根据对象存活周期不同，讲内存划分为几块，采用不同的收集算法。新生代、老年代。
  * 新生代，每次回收会有大批对象死去，少量存活，采用复制算法。
  * 老年代，对象存活率较高，没有额外空间对它分配担保，才有标记清理或标记整理算法。

## 三、HotSpot的算法实现

### 1.枚举根节点

​	在可达性分析算法中，从GC Roots节点找到引用链为例，可作为GC Roots的节点一般为**全局引用（常量或类静态属性）或执行上线文（栈帧中的本地变量表）**，现在很多引用方法区都有数百兆，逐个检查引用，必定要消耗很多时间。

​	可达性分析算法对执行时间敏感，在执行该算法时，整个执行系统看起来像被冻结到某个时间点上，不能出现分析过程中对象引用不断变化的情况，否则无法保证分析结果的正确性。这一点是导致GC进行时必须停顿所有的Java执行线程（Stop The World）的一个重要原因，即时在号称不会发生停顿的CMS收集器中，枚举根节点也是必须要停顿的。	

​	目前主流的虚拟机都是采用准确式的GC，当执行系统停顿下来，不需要一个不漏检查完执行上下文和全局引用的位置，虚拟机应当有办法知道哪些地方存在引用。在HotSpot实现中，使用OopMap的数据结构来完成，类加载完成之后，HotSpot把对象内什么偏移量上是什么类型的数据计算出来了，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是被引用的。这样，在GC扫描的时候，只扫描被引用的位置。

### 2.安全点

​	在OopMap的协助下，JVM可以快速确定GC Roots枚举，但是存在引用关系变化，或者说OopMap内容变化的指令非常多，如果每条变化都产生一个OopMap，将会需要大量额外空间，这样GC的空间成本会很高。实际上，HotSpot没有为每条指令都生成OopMap，只是在“特定位置”记录这些信息，这些位置称为“安全点”，即程序执行的时候，只有在安全点才发生GC（程序暂停）。

​	Safepoint的选定既不能太多（频繁GC导致负荷增大），也不能太少（GC等待时间过长），所以安全点的选定的标准是“是否具有让程序长时间执行的特征”，例如方法调用，循环跳转，异常跳转等。

​	对于Safepoint，另一个需要考虑的问题是如何保证所有的线程（不包括JNI线程）都在安全点停下来，有两种方案：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）。

* 抢先式中断不需要线程的执行代码配合，在GC发生时，中断所有线程，如果发现有线程不在安全点上，恢复线程，让它执行到安全点，现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC。
* 主动中断的思想是，当GC需要中断线程时，不直接中断线程，而是设置一个标志，各个线程执行时轮询该标志，发现中断标志为真时自己主动中断挂起。轮询标志的地址和安全点重合，再加上创建对象分配内存的地方。

### 3.安全区域

​	Safepoint机制保证了程序执行时，在不太长时间就会遇到可进入GC的Safepoint。但程序不执行的时候，没有分配CPU时间，典型的例子是线程睡眠或阻塞状态，线程无法响应JVM的中断请求，无法执行到安全点中断自己，JVM也不太可能等待线程重新被分配CPU时间。这种情况，需要安全区域（Safe Region）来解决。

​	Safe Region是指在一段代码片段之中，对象引用关系不会发生变化。这个区域的任何地方都可以GC，可以把Safe Region是Safepoint的扩展。线程执行到Safe Region时，首先标志自己已经进入Safe Region，当在这段时间JVM要发起GC时，不用管标识自己为Safe Region状态的线程，在线程要离开Safe Region时，它要检查整个系统是否完成GC，如果完成，线程继续执行，否则必须等待，直到收到可以离开Safe Region的信号为止。

##  四、垃圾收集器

​	虽然我们对各个收集器进行比较，但并非挑选一个最好的收集器，因为目前为止还没有最好的收集器出现，更加没有万能的收集器，我们选择的只是对具体应用最适合的收集器。

![img](http://img-blog.csdnimg.cn/20181219110924217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzYyNzc1,size_16,color_FFFFFF,t_70) 

### 1.Serial收集器

* 最基本，历史最悠久的收集器，JDK1.3之前是新生代收集唯一的选择。
* 单线程收集器，它在垃圾收集时，必须暂停所有工作线程，直到它收集结束。
* Client模式下默认新生代收集器。

### 2.ParNew收集器

* Serial的多线程版本，单CPU下没Serial效率高，CPU增加ParNew效果明显。
* 除Serial外，只有ParNew能配合CMS的老年代收集器。

**并行（Parallel）：指多条垃圾收集线程并行执行，但是此时用户线程处于等待状态。**

**并发（Concurrent）：指用户线程和垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户线程在继续执行，而垃圾收集程序运行在另一个CPU上。**

### 3.Parallel Scavenge收集器

* 采用复制算法，并行的多线程收集器。
* 目标是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)。停顿时间越短适合需要用户交互的程序，而高吞吐量可以高效利用CPU时间，尽快完成运行任务，主要适合后台运算而不需要太多交互的任务。
* Parallel Scavenge收集器提供两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间`--XX:MaxGCPauseMillis`参数和直接设置吞吐量大小的`--XX:GCTimeRatio`参数。
* 吞吐量有限收集器，虚拟机会根据当前系统的运行情况，收集器性能监控信息，动态调整参数以提供最适合的停顿时间或最大吞吐量，这种调节方式称为GC自适应调节策略（GC Ergonomics）。

### 4.Serial Old收集器

* serial收集器老年代版本，单线程收集器，采用“标记-整理”算法。
* 主要给Client模式下老年代用。
* 如果在Server模式下，JDK1.5前与Parallel Scavenge收集器搭配使用；作为CMS收集器的备选。

### 5.Parallel Old收集器

* Parallel Scavenge收集器的老年代，多线程“标记-整理”算法。
* 配合新生代Parallel Scavenge收集器使用。

### 6.CMS收集器

* CMS收集器以获取最短回收停顿时间为目标。
* 标记-清除算法实现，分4个步骤
  * 初始标记。仅仅标记GC Roots能直接关联的对象，速度很快。时间：短
  * 并发标记。GC Roots Tracing的过程。时间：长
  * 重新标记。修正并发标记期间，被标记对象产生变化的部分。时间：中
  * 并发清除。
* 优点：并发收集，低停顿。
* 缺点：
  * 对CPU资源敏感。其实面向并发设计的程序都对CPU资源比较敏感，在并发阶段，虽然不会导致用户线程停顿，但会因此占用一部分CPU资源导致应用程序变慢，总吞吐量下降。CMS默认开启回收线程数为（CPU数量+3）/4，所消耗的资源随CPU的增加而下降。如果CPU不足4，CMS对用户程序的影响就会很大，此时虚拟机提出了“增量式并发收集器”（I-CMS）,使用抢占式来模拟多任务机制，就是在并发标记、清理的时候让GC线程和用户线程交替运行，尽量减少GC线程所独占资源的时间，这样整个GC时间会变长，对用户程序的影响就会显得少，但是下降没有很明显，所有虚拟机默认关闭，不推荐使用。
  * CMS无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理垃圾阶段，用户线程还在运行，伴随着程序的运行，会有新的垃圾不断产生，这部分垃圾在标记之后，CMS无法在当次收集中处理掉它们，这部分垃圾称为“浮动垃圾”。也是由于收集时，用户线程还在运行，，不能等到老年代几乎完成被填满时再收集，需要预留足够的内存空间给用户线程使用。JDK1.5，老年代68%后就会被激活，JDK1.6，92%，如果预留的内存不够用户程序使用，会出现“Concurrent Mode Failure”失败，这时会临时启用Serial Old收集器来重新对老年代的垃圾收集，这样停顿时间就很长了。
  * 由于CMS是采用”标记-清除“算法，所以收集结束会产生大量的内存碎片，碎片过多，会对大对象分配产生麻烦，往往老年代还有很多空间，但是无法找到足够连续的内存分配当前对象，不得不触发一次Full GC。解决方式：CMS收集器提供了一个`--XX:+UseCMSCompactAtFullCollection`开关的参数，默认开启，用于在CMS顶不住要进行Full GC时开启内存合并整理过程，但是内存整理过程无法并发进行，会导致停顿时间变长。此时虚拟机提供`--XX:CMSFullGCsBeforeCompaction`参数来设置执行多少次不压缩的Full GC后，跟着来一次压缩操作（默认为0，表示每次Full GC时都进行碎片整理）。

### 7.G1收集器

* G1（Garbage-First）收集器是当今收集器技术发展最前沿技术之一。
* G1是一款面向服务端应用的垃圾收集器，未来可以替换CMS收集器。
* 特点：
  * 并行与并发：G1能充分利用多CPU、多核环境下硬件资源。Java执行GC动作，G1收集器仍能通过并发的方式让Java程序继续运行。
  * 分代收集：虽然可以不依赖其他收集器独立管理整个GC堆，但它能采用不同的方式去处理新创建的对象和已经存活一段时间、熬过多次GC的旧对象以获取更好的收集效果。
  * 空间整合：整体基于“标记-整理”算法，局部（两个Region）采用“复制”算法。
  * 可预测停顿时间：减低停顿时间是CMS和G1共同关注点，但G1除了追求停顿外，会建立可预测的停顿时间模型，能让使用者明确指定在一个长度为Mms的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎是实时Java（RTSJ）的收集器特征了。
* 使用G1收集器时，Java堆的内存布局就与其他收集器有很大区别，它将堆分为多个大小相等的独立区域（Region），虽然还保留了新生代和老年代的概念，但是新生代和老年代不在隔离，他们都是一部分Region（不需要连续）的集合。
* G1收集器之所以能建立可预测的停顿时间模型，是因为它有计划的避免在整个Java堆中进行全区域的垃圾收集。G1会跟踪各个Region里面的垃圾堆积的价值（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这就是Garbage-First的由来）。
* Region不是独立的，存在不同Region对象的相互引用，在判断对象是否存活的可达性分析算法中如何避免全区域扫描。

### 8.GC日志

### 9.垃圾收集器参数总结

| 参数                           | 描述                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| UseSerialGC                    | 虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial + Serial Old的收集器组合进行内存回收 |
| UseParNewGC                    | 打开此开关后，使用ParNew + Serial Old的收集器组合进行内存回收 |
| UseConcMarkSweepGC             | 打开此开关后，使用ParNew+ CMS + Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用 |
| UseParallelGC                  | 虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old (PS Mark Sweep)的收集器组合进行内存回收 |
| UserParallelOldGC              | 打开此开关后，使用Parallel Scavenge + Parallel Old的收集器组合进行内存回收 |
| SurvivorRatio                  | 新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden: Survivor = 8:1 |
| PretenureSizeThreshold         | 直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配 |
| MaxTenuringThreshold           | 晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄就增加1，当超过这个参数值时就进入老年代 |
| UseAdaptiveSizePolicy          | 动态调整Java堆中各个区域的大小以及进入老年代的年龄           |
| HandlePromotionFailure         | 是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况 |
| ParallelGCThreads              | 设置并行GC时进行内存回收的线程数                             |
| GCTimeRatio                    | GC时间占总时间的比率，默认值是99， 即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效 |
| MaxGCPauseMillis               | 设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效  |
| CMSInitiatingOccupancyFraction | 设置CMS收集器在老年代时间被使用多少后触发垃圾收集。默认值为68%，仅在使用CMS收集器时生效 |
| UseCMSCompactAtFullCollection  | 设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效 |
| CMSFullGCsBeforeCompaction     | 设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理，仅在使用CMS收集器时生效 |

## 五、内存分配与回收策略

​	Java技术体系所提倡的自动内存管理最终是要解决两个问题，一个是垃圾回收，一个是内存分配。

​	对象的内存分配，从大方向上讲，就是在堆上分配（可能经过JIT编译后被拆散为标量类型并间接的栈上分配），对象（普通新对象）主要分配在新生代Eden区，如果启动了本地线程缓存，将按线程优先在TLAB上分配。部分对象（大对象）也可能直接分配在老年代，分配规则并不是百分百确定的，取决于当前使用的垃圾收集器组合和虚拟机内存参数。

### 1.对象优先在Eden上分配

- 大多数情况下，对象在新生代Eden区域分配，当Eden没有足够空间进行分配时，虚拟机发起一次Minor GC。
- 虚拟机提供`-XX:+PrintGCDetails`这个收集器日志参数，告诉虚拟机在发生垃圾收集时打印内存回收日志，并且在进程退出时输出当前内存分配各区域情况。
- 新生代GC（Minor GC）:指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。
- 老年代（Major GC/Full GC）：放生在老年代的GC，每次Major GC经常会伴随至少一次Minor GC（不是绝对，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略）。Major GC的速度一般比Minor GC慢10倍以上。

### 2.大对象直接进入老年代

- 大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串或者数组。大对象对虚拟机的内存分配是个坏消息（比存在大对象更糟糕的是大对象的使用周期很短），经常出现大对象容易造成还有很多内存空间时就提前触发垃圾收集来获取足够连续的空间来存放它们。
- 虚拟机提供参数`-XX:PretenureSizeThreshold`（只对Serial和ParNew两款收集器有效）来确定是否为大对象，如果超过该值，直接在老年代分配。这样避免在Eden区已经两个Survivo区之间发生大量的内存复制。

### 3.长期存活的对象将进入老年代

- 虚拟机采用分代收集的策略，那么它就需要知道哪些对象应放什么区域（新生代、老年代）。为了做的这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。
- 如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且能被Survivor容纳，那么它将被移动到Survivor空间中，并且对象年龄设为1。对在Survivor空间中，每熬过一次Minor GC，age都会加1，当age增加到一定程度（默认为15岁），将会被晋升到老年代。可以通过`-XX:MaxTenuringThreshold`参数来设置年龄阈值。

### 4.动态年龄判断

​	为了更好的适应不同程序的内存情况，虚拟机并不是永远地要求对象的年龄必须达到设定的年龄阈值才能晋升老年代，如果Survivor空间中相同年龄所有对象的总和大于Survivor空间的一半，年龄大于或等于该相同年龄的对象就会直接进入老年代，无需等到设定的年龄阈值。

### 5.空间分配担保

​	在放生Minor GC之前，虚拟机总会检查老年代最大可用连续的内存是否大于新生代所有对象的总空间，如果成立，则确保该次Minor GC是安全的。如果不成立，虚拟机会查看`HandlePromotionFailure`设置的值是否允许担保失败。如果允许，那么继续检查老年代最大可以连续内存是否大于历次晋升老年代对象的平均值，如果大于，尝试一次Minor GC，尽管这次GC存在风险。如果小于，或者设置的`HandlePromotionFailure`不允许冒险，这时要进行一次Full GC。

## 六、字节码

### 1.Class类文件数据结构

​	Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在Class文件中，中间没有任何分隔符，这使得Class文件中的内容都是程序运行的必要数据。当需要8位字节以上空间的数据项时，则会按照高位在前（Big-Endian）的方式分割成若干个8位字节存储。Big-Endian具体指的是最高位字节在地址最低位、最低位字节在地址最高位的顺序来存储。

根据Java虚拟机规范，Class文件格式采用伪结构来存储数据，只有两种数据类型：无符号数和表。

- 无符号数属于基本数据类型，以u1,u2,u4,u8来分别代表1个字节，2个字节，4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符串值。
- 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有的表都习惯性以“_info”结尾。表用于描述有层次关系的复合结构数据，整个Class文件本质上是一张表。
- 无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，会使用一个前置的容器计数器加若干连续的数据项形式，这是称这一系列连续的某一类型的数据为某一类型的集合。

#### 魔数

* 每个Class文件的前4个字节称为魔数，它的唯一作用是确定这个Class文件是否为能被虚拟机接受的Class文件。很多文件存储标准中都使用魔数来进行身份识别，譬如gif，jpeg等文件头中都有魔数。使用魔数而不是扩展名来进行识别，主要是基于安全方面的考虑，因为扩展名可以随意改动。

* Class文件的开始的魔数为0xCAFEBABE（咖啡宝贝），紧接着的4个字节的魔数是Class文件的版本号：第5个和第6个字节是次版本号，第7个和第8个字节是主版本号。Java的版本号是从45开始的，JDK1.1之后的每个JDK大版本发布主版本号向上加1，高版本的JDK能向下兼容以前版本的Class文件，但不能运行更高版本的Class文件，即使文件格式没有发生任何变化，虚拟机也不能执行超过当前JDK版本的Class文件。

#### 常量池

* 紧接着主版本号的是常量池入口，常量池可以理解为Class文件的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时也是Class文件中第一个出现表类型数据的项目。
* 由于常量池中常量的数量是不固定的，所以常量池的入口需要放置一项u2（2个字节）类型的数据，代表常量池容量计数值，这个容量值是从1开始的。常量池容量（偏移地址：0x00000008）为16进制数的0x0016，即十进制的22，这代表常量池中有21个常量，索引范围为1~21。在Class文件规范制定时，设计者将第0项常量空出来是为了满足，后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这时索引值置为0。
* Class文件只有常量池的索引从1开始（0表示不引用任何常量池），对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都是从0开始。
* 常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic Reference）。字面量比较接近Java语言层面的常量概念，如文本字符串、声明为final的常量值等。符号引用则是属于编译原理方面的概念，包括下面三类常量：
  * 类和接口的全限定名
  * 字段的名称和描述符
  * 方法的名称和描述符
* Java代码在Javac编译的时候，不会像C++有“连接”的动作，而在虚拟机加载Class文件的时候进行动态连接。也就是说，在Class文件中并不会保存各个方法、字段的最终内存信息，因此这些字段、方法的符号引用在不经过运行期转换的话无法得到程序的真正的内存入口地址，也无法直接被虚拟机使用。在虚拟机运行时，需要从常量池中获取对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中。
* 常量池中每一项常量都是一个表，JDK7之前有11种结构各不相同的表结构数据，JDK1.7中为了更好地支持动态语言调用，额外增加三种。这14种表结构开始的第一位都是u1类型的标志位，代表当前这个常量属于哪种常量类型。
* Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，CONSTANT_Utf8_info的最大长度就是Java中方法、字段名的最大长度，即u2类型能表达的最大值65535，所以Java程序如果定义了超过64KB英文字符的变量或变量名，将无法编译。

#### 访问标志

* 常量池结束之后，紧接的两个字节表示访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括Class是类还是接口；是否定义为public类型；是否定义为abstract类型。如果是类，是否被声明为final等。

  ![img](http://ww1.sinaimg.cn/large/af7d73dftw1erdhzuodpvj20wu0dqgq3.jpg) 

* access_flags中一共有16个标志位可以使用，当前只定义了其中8个，没有使用到的标志位要求一律为0。

#### 父索引，父类索引与接口索引集合

​	类索引和父类索引都是u2类型的数据，而接口索引集合是一组u2类型的数据集合，Class文件中由这三项数据确定继承关系。类索引用于确定该类的全限定名，父类索引确定这个类的父类的全限定名。由于Java不能多继承，所以父类索引只有一个，除Object类外，任何类的父类索引不为0。接口索引集合就是用来描述这个类实现了哪些接口，这些被实现的接口将按照实现顺序依次排列在接口索引集合中。如果类本身是一个接口，则是被继承接口。

#### 字段表集合

​	字段表（field_info）用于描述接口或类中定义的变量。字段包含类级变量和实例级变量，但不包含方法中声明的局部变量。

​	Java中描述一个字段可以包含的信息：字段作用域、实例变量还是类变量、可变性、并发可见性、是否被序列化（transient修饰符）、字段数据类型、字段名称。而字段叫什么名称、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。

#### 方法表集合

​	Class文件中对方法的描述与字段的描述一样，方法表的结构如同字段表一样，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attribute）几项。

#### 属性表集合

​	与其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松些，不再要求各属性表具有严格的顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。

1. Code属性

   * Java程序方法体中的代码经过javac编译器处理后，最终变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合中，但并非所有的方法表中都包含Code属性，如接口或抽象类中的方法就不存在Code属性（JDK8存在默认函数）。
   * Code属性是Class文件中最重要的一个属性，如果把Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么整个Class文件中，Code属性用于描述代码，所有其他数据项目都是描述元数据。

2. Exceptions属性

   ​	Exceptions属性与Code属性在方法表中同一级，不是异常表。Exceptions属性的作用是列举出方法中可能抛出的受检查异常（Check Exception），也就是方法描述时在throws关键字后面列举的异常。

3. LineNumberTable属性

   ​	用于描述Java源码行号与字节码行号（字节码的偏移量）之间的关系。它并不是运行时必须的属性，但默认会生成到Class文件中，可以在javac中分别使用`-g:none`或`-g:lines`选项来取消或要求生成这项信息。如果选择不生成，对程序最主要的影响是当抛出异常时，堆栈中将不会显示出错行号，并且在调试程序时，也无法按照源码行设置断点。

4. LocalVariableTable属性

   ​	用于描述栈帧中局部变量表中的变量与Java源码中定义的变量的关系，它也不是必须的，但默认会生成到Class文件中。可以在javac中使用`-g:none`或`-g:vars`来取消或生成。如果没有该项信息，当其他人引用这个方法时，所有的参数名称都将会丢失，IDE会使用诸如arg0,arg1之类的占位符来代替原有的参数名，这对程序没有影响，会对代码编写带来很大的不便，而且在调试期间无法根据参数名称获取参数值。

5. SourceFile属性

   * 记录生成这个Class文件的源码文件名称。
   * 可选，`-g:none`或`-g:source`来取消或生成。
   * Java中对大多数类，类名和文件名一致（内部类例外）。
   * 如果不生成这个属性，当抛出异常时，堆栈信息不会显示出错代码文件名。
   * 定长属性。

6. ConstantValue属性

   * 作用是通知虚拟机自动为静态变量赋值。
   * 只有被static修饰的变量才能使用这个属性。
   * 只限于基本属性和String。
   * 定长属性。

7. InnerClasses属性

   * 记录内部类和宿主类之间的关联。
   * inner_name_index指向常量池中CONSTANT_Utf8_info型常量的索引，代表内部类的名称，如果是匿名内部类，值为1。

8. Deprecated及Synthetic属性

   * 都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。
   * Deprecated属性用于表示某个类、方法或字段，已被作者定为不推荐使用，可以在代码中通过`@deprecated`注释进行设置。
   * Synthetic属性代表此字段或方法并不是有Java源码直接产生的，而是由编译器自行添加的。

9. StackMapTable属性

   * JDK1.6后增加到Class文件规范中，复杂的变长属性，位于Code属性的属性表中。
   * 会在虚拟机类加载的字节码验证阶段被新类型检查验证器（Type Checker）使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。

10. Signature属性

   * JDK1.5后增加到Class文件规范中，可选定长属性，出现在类、属性表和方法表结构的属性表中。
   * 记录泛型签名信息，Java语言采用的是擦除法实现的伪泛型，在字节码（Code属性）中，泛型信息编译（类型变量，参数化类型）之后，都会被统统擦除。

11. BootstrapMethod属性

    * JDK1.7增加到Class规范中，复杂的变长属性，位于类文件的属性表中。
    * 用于保存invokedynamic指令引用的引导方法限定符。

### 2. 字节码指令简介

​	Java虚拟机的指令是有一个字节长度的，代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟其后的零至多个代表此操作所需参数（操作数，Operands）而构成。由于虚拟机采用的面向操作数栈帧而不是寄存器的架构，所以大多数的指令都不含操作数，只有操作码。

​	字节码指令集是一种具有鲜明特点、优劣势都很突出的指令集架构，由于限制了Java虚拟机操作码的长度为一个字节（即0~255），这意味着指令集的操作码总数不能超过256条；由由于Class文件放弃了编译后代码的操作数长度对齐，这就意味着虚拟机处理那些超过一个字节数据时，不得不在运行时从字节中重建出具体的数据结构。这样做会导致解释执行字节码时损失一些性能，但优势也很明显，放弃了操作数长度对齐，意味着可以省略很多填充和间隔符号。用一个字节来代表操作码，也是为了尽可能获得短小精干的编译代码。

#### 字节码与数据类型

* Java虚拟机指令集中，大多数指令都包含其操作所对应的数据类型信息。如，iload指令用于从局部变量表中加载int类型的数据到操作数栈中，fload加载float类型的数据。这两条指令的操作在虚拟机内部可能是有一段代码实现，但在Class文件中它们必须拥有各自独立的操作码。

#### 加载和存储指令

* 加载和存储指令，用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，内容如下：
  * 将一个局部变量加载到操作数栈：iload、iload_<n>、lload等。
  * 将一个数值从操作数栈存储到局部变量表中：istore、istore_<n>、lstore等。
  * 将常量加载到操作数栈：bipush、sipush、ldc等。
  * 扩展局部变量表的访问索引的指令：wide。
* 存储数据的操作数栈和局部变量表主要就是由加载和存储指令进行操作，除此之外还有少量指令，如访问对象的字段或数组元素的指令也会向操作数栈传输数据。
* iload_<n>这些指令实际上代表一组指令(iload_0,iload_1)。

#### 运算指令

* 运算和算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入操作数栈顶。
* 算术指令分为两种：整数运算和浮点运算。

#### 类型转换指令

* 类型转换指令可以将两个不同类型数据进行相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作。
* Java虚拟机直接支持宽化类型转换，即小范围型向大范围型的安全转换，相对的窄化型转换必须显式使用转换指令来完成。窄化型转换可能导致转换结果产生不同的正负号、不同的数量级、精度丢失等问题。

#### 对象创建和访问指令

* 虽然类实例和数组都是对象，但是Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令（数组和不同实例的创建过程不同）。对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的元素。

#### 操作数栈管理指令

* 如同操作普通数据结构中的堆栈一样，Java虚拟机提供了直接操作操作数栈的指令。如;
  * 将操作数栈的栈顶一个或两个元素出栈：pop、pop2
  * 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1
  * 将栈顶两个数值互换：swap

#### 控制转移动指令

* 控制转移指令可以让Java虚拟机有条件或无条件地从指定的位置指令继续执行程序（而不是控制转移指令的下一条指令），从模型上理解，可以认为控制转移指令就是在有条件或无条件的修改PC寄存器的值。
* 在虚拟机中有专门的指令集来处理int和reference类型的条件判断操作，为了可以无须显式标识一个实体值是否为null，也有专门的指令检测null值。

#### 方法调用和返回指令

* invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。
* invokeinterface指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出合适的方法进行调用。
* invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。
* invokestatic用于调用类方法（static修饰的方法）
* invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，前面4条指令的分配逻辑都固化在Java虚拟机内部，而invokedynamic指令的分配逻辑是由用户所设定的引导方法决定的。
* 方法调用方法与数据类型无关，而返回指令是根据方法返回值类型区分的。

#### 异常处理指令

* 在Java程序中显式抛出异常的操作（throw语句）都是由athrow指令完成的。
* 运行时异常会在其他Java虚拟机指令检测到异常状况自动抛出。
* Java虚拟机，处理异常不是由字节码指令来实现的，而是采用异常表来完成。

#### 同步指令

* Java虚拟机支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管称（Monitor）来支持的。
* 方法级的同步是隐式的，即无需通过字节码指令来控制，它的实现在方法调用和返回操作之中。
* 虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED的访问标志得知一个方法是否声明为同步方法，方法调用时将检查ACC_SYNCHRONIZED标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论正常完成还是非正常完成），释放管程。在方法执行期间，执行线程持有管程，其他任何线程都无法获取同一个管程。如果同步方法执行期间抛出异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的管程将在异常抛出到同步方法之外时自动释放。
* 同步一段指令集序列通常是有Java语言的synchronized语句块来表示，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持，正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持。
* 编译器必须确保无论方法通过何种方式完成，方法中调用的每条monitorenter指令都必须执行对应的monitorexit指令，无论这个方法是正常结束还是异常结束。
* 为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理的所有异常，它的目的就是用来执行monitorexit指令。

![åæ­¥ä»£ç å­èç åæ.png](https://github.com/gnng/bookList/blob/master/image/%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90.png?raw=true) 

### 3.共有设计和私有实现

* Java虚拟机规范描绘了Java虚拟机应有的共同程序存储格式Class文件格式以及字节码指令集。这些内容与硬件、操作系统及具体的Java虚拟机实现之间是完全独立的，虚拟机实现者可能更愿意把它们看做是程序在各种Java虚拟机实现之间相互安全转换的手段。
* Java虚拟机实现必须能够读取Class文件并精确实现包含在其中的Java虚拟机代码的语义。拿着Java虚拟机规范一成不变地逐字实现其中要求的内容当然是可行的，但是一个优秀的虚拟机实现，在满足虚拟机规范的约束下对具体实现做出修改和优化也是可行的，只要优化后的Class文件可以被正确读取。
* 虚拟机实现者可以使用这种伸缩性让Java虚拟机获得更高的性能、更低的内存消耗或者更好的可移植性，选择哪种特性取决于Java虚拟机实现的目标和关注点。虚拟机实现主要有两种方式：
  * 将输入的Java虚拟机代码在加载或执行时翻译成另一种虚拟机的指令集。
  * 将输入的Java虚拟机代码在加载或执行时翻译成宿主机CPU的本地指令集（JIT代码生成技术）。

## 七、虚拟机类加载机制

### 1. 概述

​	虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机直接使用的Java类型，这就是虚拟机类加载机制。

​	与那些编译时需要进行连接的语言不同，在Java语言里面，类的加载、连接和初始化的过程都是在程序运行期间完成的，这种策略虽然会使类加载时消耗一些性能，但为Java程序提供了高度的灵活性，Java可以动态扩展的语言特性就是依赖运行期动态加载和动态连接实现的。例如，编写一个面向接口的应用程序，可以等到运行时再指定具体的实现类；用户可以通过Java预定义的和自定义类加载器，让一个本地的应用程序在运行时可以从网上或其他地方加载一个二进制流作为程序代码的一部分。

### 2. 类加载时机

* 类从被加载到内存中开始，到卸载出内存为止，它的整个生命周期为：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段。其中验证、准备、解析3个部分统称为连接（Linking）。
* 加载、验证、准备、初始化和卸载这5个阶段的顺序是固定的，类的加载必须按整个顺序按部就班地开始，而解析阶段不一定：在某些情况下可以在初始化之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。这些阶段通常都是相互交叉地混合进行的，通常会在一个阶段执行过程中调用、激活另一个阶段。
*  对于**初始化阶段** ，虚拟机规范严格规定了有且只有5种情况必须对类进行初始化（加载、验证、准备需要在此之前开始）：
  * 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行初始化，则需要先触发其初始化。最常见的场景是使用new关键字实例化对象时候、读取或设置一个类的静态字段（被final修饰、已在编译期已把结果放入常量池的静态字段除外），以及调用一个类的静态方法的时候。
  * 使用`java.lang.reflect`包的方法对类进行反射调用的时候，如果类没有进行初始化，需要先进行初始化。
  * 当初始化一个类的时候，发现其父类没有初始化，则要先初始化其父类。
  * 当虚拟机启动时，用户需要指定一个要执行的主类（包含`main()`方法的那个类），虚拟机会先初始化这个类。
  * 当使用JDK1.7的动态语言支持时，如果一个`java.lang.invoke.MethodHandle`实例最后的解析结果`REF_getstatic`、`REF_putstatic`、`REF_invokestatic`的方法句柄时，并且这个方法句柄所对应的类没有初始化过，则需要先触发其初始化。
* 对于这5中，虚拟机规范中强烈限定“有且仅有”，这5中场景的行为称为对一个类的主动引用，除此之外，所有引用类的方式都不会触发初始化，称为被动引用。

### 3. 类加载的过程

#### 加载

* 加载是类加载过程中的一个阶段，在加载阶段虚拟机会完成一下3件事：

  * 通过一个类的全限定名来获取定义此类的二进制字节流。

    * 虚拟机没有明确指定二进制流要从一个Class文件中获取，准确说根本没有指明二进制文件来源。所以可以从以下几种方式中读取二进制流：

      * 从ZIP包中读取，最终成为JAR、EAR、WAR格式的基础。

      * 从网络中获取，最常见的就是Applet。

      * 运行时计算生成，这种场景使用最多的就是动态代理技术，在`java.lang.reflect.Proxy`就是用`ProxyGenerator.generateProxyClass`类来为特定接口生成形式为“*Proxy”的代理类的二进制字节流。

      * 由其他文件生产，典型场景JSP，即JSP文件生成对应的Class类。

      * 从数据库中读取，使用场景较少，可以选择把程序安装到数据库中来完成程序代码在集群中的分发

        ......

  * 将字节流所代表的静态存储结构转化为方法区的运行时数据结构。

  * 在内存上生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据访问入口。

* 相对于类加载过程的其他阶段，一个非数组类的加载阶段是可控性最强的，因为加载既可以用系统提供的引导类加载器来完成，也可以由用户自定义类加载器去完成，开发人员可以自定义类加载去控制字节流的获取方式（即重写一个类加载器的`loadClass()`方法）。

* 对于数组，加载不是通过类加载器实现的，而是由Java虚拟机直接创建。但数组和类加载器仍有密切关联，因为数组类的元素类型还是通过类加载器创建的，一个数组类创建过程要遵循一下原则：

  * 如果数组的组件类型（数组去掉一个维度的类型）是引用类型，就递归采用定义的加载过程来加载这个组件类型，数组类将在加载该组件类型的类加载器的类名称空间上标识（一个类必须与一个类加载一起确定唯一性）。
  * 如果数组组件类型不是引用类型（例如：int[]数组），Java虚拟机将会把数组类标记为与引导类加载器关联。
  * 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性默认为public。

* 加载阶段完成后，虚拟机外部的二进制字节流将按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个`java.lang.Class`类的对象（它虽然是对象，但是在方法区），这个对象将作为程序访问方法区中这些类型数据的外部接口。

* 加载阶段与连接阶段的部分内容是交叉执行的，加载阶段还没完成，连接阶段可能已经开始，但这些夹在加载阶段之中的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持固定的顺序。

#### 验证

* 验证是连接阶段的第一步，确保Class文件的字节流中信息是否符合虚拟机要求，并且不会危害到虚拟机自身安全。

* Java语言本事是相对安全的语言，如果不检查输入的字节流，很可能会载入了有害的字节流，导致系统崩溃。

* 验证阶段是非常重要的，这个阶段是否严谨直接决定Java虚拟机是否能承受恶意的代码攻击。

* 从执行性能上讲，验证阶段的工作量在虚拟机的类加载子系统中占有相当大一部分。

* 验证阶段大致会经过4个检验工作：文件格式验证、元数据验证、字节码验证、符号引用验证。

  1. 文件格式验证。验证字节流是否符合虚拟机规范，并能在当前版本的虚拟机中处理。

     - 是否以魔数0xCAFEBABE开头。

     - 主，次版本号是否在当前虚拟机处理范围之内。

     - 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。

     - 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。

     - CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。

     - Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。

       ......

     实际上，文件格式验证远远不止这些，该阶段主要是保证输入的字节流能正确地解析并存储与方法区之内，格式上符合描述一个Java类型信息的要求。这个阶段验证是基于二进制字节流进行的，只有通过这个阶段验证，字节流才会进入内存的方法区进行存储，后面的3个验证阶段都是基于方法区的存储结构进行的，不会再直接操作字节流。

  2. 元数据验证。第二阶段是对字节码描述的信息进行语义分析，以确保其描述的信息符号Java语言规范要求。可能包含以下验证点：

     * 这个类是否有父类（除`java.lang.Object`类之外，其他类都应当父类）。
     * 这个类~~（的父类）~~是否继承了不被允许继承的类（被final修饰的类）。
     * 如果这个类不是抽象类，是否实现了其父类或接口中所有要求实现的方法。
     * 类中的字段、方法是否与父类产生矛盾（覆盖了父类final修饰的字段，或出现了不符合规则的方法重载，例如方法参数一致，但返回类型不同）。

     ......

  3. 字节码验证。第三个阶段是整个验证过程最复杂的阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。第二阶段是对元数据信息中的数据类型检验，这个阶段对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，如：

     * 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，不会出现类似于在操作数栈放置了一个Int类型的数据，使用时却按long类型加载如本地变量表。

     * 保证跳转指令不会跳转到方法体之外的指令上。

     * 保证方法体中类型转换是有效的。

       ......

     如果一个类方法体，没有通过字节码校验，那肯定是有问题，但是如果通过也不能说它一定是安全的。即使字节码验证中进行了大量的检验，但是也不能保证这一点，通过程序去检验程序逻辑是无法绝对准确的--不能通过程序准确地检查出程序是否能在有限的时间内结束运行。

  4. 符号引用验证。最后一个阶段发生在虚拟机将符合引用转换为直接引用时候，这个转化动作将在连接的第三个阶段-解析阶段发生。符合引用验证可以看做是对类自身以外的信息进行匹配性校验，通常校验一下内容：

     * 符合引用中通过字符串描述的全限定名是否能找到对应类。
     * 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。
     * 符合引用中的类、字段和方法的访问性是否可被当前类访问。

     符合引用验证的目的是确保解析阶段能够正常执行，对于虚拟机的类加载机制来说，验证阶段是一个非常重要、但不一定是必要（对程序运行期没有影响）的阶段。如果运行的全部代码都已经经过反复使用和验证过，可以使用`-Xverify:none`参数来关闭大部分的类验证措施，以缩短虚拟机类加载时间。

#### 准备

​	准备阶段正式为类变量分配内存并设置初始值，这些变量所使用的内存在方法区分配。这个时候的内存分配仅包括类变量（被static修饰的变量），不包含实例变量，实例变量将在对象实例化的时候在堆上分配。

​	变量在准备阶段过后的初始值为0，这时尚未执行任何Java方法，而变量赋值的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所有的赋值操作都会在初始化阶段执行。

#### 解析

​	解析阶段是虚拟机将常量池内的符号引用转为直接引用的过程。

* 符号引用（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符号可以是任意形式的字面量，只要使用时无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是他们能接受的符号引用必须一致，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件中。
* 直接引用（Direct Reference）：直接引用可以是直接指向目标的指针、相对偏移量或者是一个能够间接定位到目标的句柄。直接引用与内存布局有关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不相同。如果有了直接引用，那引用的目标必定已经存在于内存中。

#### 初始化

​	初始化时类加载过程的最后一步，前面类加载过程中，除了加载用户自定义的类加载器参与外，其余动作都是由虚拟机主导和控制的。初始化阶段才真正执行类中定义的Java程序代码（或者说是字节码）。

​	在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者说初始化阶段是执行类构造器`<clinit>()`方法的过程。

* `<clinit>()`方法是由编译器自动收集类中所有的类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的静态变量，定义在它之后的变量，在静态语句块中可以赋值，但不能访问。
* `<clinit>()`方法与类的构造函数（实例构造器`init()`方法）不同，它不需要显示的调用父类构造器，虚拟机会保证在`<clinit>()`方法执行之前，父类的`<clinit>()`已经执行完毕，因此在虚拟机第一个被执行的`<clinit>()`方法的类肯定是`java.lang.Object`类。
* 由于父类的`<clinit>()`先执行，那么父类定义的静态语句块要优先于子类的变量赋值操作。
* `<clinit>()`方法对于类和接口来说并不是必须的，如果一个类中没有静态语句块或静态变量的赋值操作，那么编译器不会为这个类生产`<clinit>()`方法。
* 接口中不能使用静态语句块，但仍然有静态变量赋值操作，因此接口和类都要生成`<clinit>()`方法。但与类不同的是，接口的`<clinit>()`方法不需要先执行父类的`<clinit>()`方法。只有当父接口定义的变量使用时，父接口才会初始化，另外，接口的实现类在初始化时也一样不会执行接口的`<clinit>()`方法。
* 虚拟机会保证一个类的`<clinit>()`方法在多线程中被正确地加锁、同步，如果多线程同时初始化一个类，那么只会有一个线程执行这个类的`<clinit>()`方法，其他线程都需要阻塞等待，直到活动线程执行`<clinit>()`方法完毕。如果在一个类的`<clinit>()`方法中有很耗时的操作，可能造成多个线程阻塞（虽然其他线程被阻塞，但如果执行`<clinit>()`方法的线程退出`<clinit>()`方法后，其他线程唤醒后也不会进入`<clinit>()`方法，同一个类加载器下，一个类型只会初始化一次），在实际应用中这个阻塞往往是很隐蔽的。

### 4. 类加载器

​	虚拟机设计是把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放在Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为‘’类加载器“。

​	类加载是Java语言的一项创新，一个Java语言流行的重要原因之一。类加载器在类层次划分、OSGi、热部署、代码加密等领域大放异彩，成为Java技术体系中的一块重要基石。

#### 类与类加载器

​	类加载器虽然只用于实现类的加载动作，但它的作用远远不止类加载阶段。对于任意一个类，都需要这个类本身和加载它的类加载器一同确立其在Java虚拟机中的唯一性，每个类加载器，都拥有一个独立的类名称空间。通俗点：比较两个是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即时这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，这两个类必定不相等。

​	这里所指的“相等”，包括代表类的Class对象的`equals()方法、isAssignableFrom()方法、isInstance()`方法的返回结果，也包括使用`instanceof`关键字做对象所属关系判定等情况，如果没有注意到类加载器的影响，在某些情况下会产生迷惑性的结果。

#### 双亲委派模型

​	从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这类加载器使用C++实现，是虚拟机自身的一部分；另一种是所有其他类加载器，这些类加载器都是由Java语言实现，独立于虚拟机外部，并且都全部继承自抽象类`java.lang.ClassLoader`。

​	从Java程序员角度，还可以分更细致点，绝大多数Java程序都会使用一下3种系统提供的类加载器。

* 启动类加载器（Bootstrap ClassLoader）：这个类加载器负责将存放在<JAVA_HOME>\lib目录中，或者被`-Xbootclasspath`参数所指定的路径中，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字如果不符合的类库，即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派到引导类加载器，直接使用null代替即可。
* 扩展类加载器（Extension ClassLoader）：这个类加载器由`sun.misc.Launcher#ExtClassLoader`实现，它负责加载<JAVA_HOME>\lib\ext目录中的，或被`java.ext.dirs`系统变量所指定路径的所有类库，开发者可以直接使用扩展类加载器。
* 应用程序类加载器（Application ClassLoader）：这个类加载器由`sun.misc.Launcher#AppClassLoader`实现。由于这个类加载器是由ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用和这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般这个就是程序默认的类加载器。

		我们的应用程序都是由这3种类加载器相互配合进行加载的，如果有必要还可以加入自己定义的类加载器。类加载器之间的层次关系称为类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是使用组合关系来复用（Composition）类加载器代码。它并不是强制性的约束模型，而是设计者推荐的一种类加载器实现方式。

		双亲委派的过程：如果一个类加载器收到类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的类加载请求最终都应该传送到顶层类加载器中，只有当父类加载器反馈自己无法完成加载请求（它搜索范围没有找到所需的类）时，子类加载器才会尝试自己加载。
		
		使用双亲委派模型来组织类加载器之间的关系，好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类`java.lang.Object`，它存放在rt.jar中，无论哪一个类加载器要加载这个类，最终都委派到Bootstrap ClassLoader类加载器加载，因此Object类在程序的各个类加载器环境中都是同一个类。相反，如果没有双亲委派模型，由各个类加载器自行加载的话，由于每个类加载都有独立的类名称空间，就会导致多个不同的Object类，Java类型体系最基础的行为也无法保证，程序将一片混乱。
		
		双亲委派模型对保证Java程序的稳定运行很重要，但它实现比较简单，都集中在`java.lang.ClassLoader`的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父类加载器。如果父类加载失败，抛出`ClassNotFoundException`异常后，再调用自己的findClass()方法进行加载。

#### 破坏双亲委派模型

​	由于双亲委派模型不是强制约束的，只是设计者推荐的一种类加载器实现方式。Java中大部分的类加载都遵守这个模型，但有例外，出现过三次较大规模“破坏”情况。

* JDK1.2之前（JDK1.2引入的双亲委派模型），抽象类`java.lang.ClassLoader`（在JDK1.0）就已经存在，面对已经存在的用户自定义类加载器的实现代码，为了向前兼容，设计者在JDK1.2之后的`java.lang.ClassLoader`添加了一个新的protected方法findClass()，在此之前，用户去继承`java.lang.ClassLoader`的唯一目的就是重写loadClass()方法。
* 第二次是由自身缺陷导致，双亲委派模型很好地解决了各个类加载器的基础类的统一问题，基础类总是被用户代码调用的API，但是如果基础类要回调用户代码，怎么办？Java设计团队引入的线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过`java.lang.Thread`类的`setContextClassLoader()`方法进行设置，如果创建线程时还未设置，它将从父线程中继承，如果在应用程序全局都没有设置，那这个类加载器默认就是应用程序类加载器。JNDI服务使用这个线程上下文类加载器去加载所需的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为破坏了双亲委派模型，但是无可奈何。Java中所涉及SPI的加载动作基本上都是采用这种方式，例如JNDI、JDBC、JCE、JAXB和JBI等。
* 第三次"破坏"是由于用户对程序动态性的追求导致的，代码的热替换（HotSwap）、模块热部署（Hot Deployment）等，说白了就是应用程序修改代码后，不重启直接可以使用。OSGi类加载器。

## 八、虚拟机字节码执行引擎

### 1. 概述

​	执行引擎是虚拟机最核心的组成部分之一。虚拟机是针对于物理机提出的概念，两种机器都有代码执行能力，区别是物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面的，而虚拟机的执行引擎是由自己实现的，因此可以自行制定指令集和执行引擎的结构体系，并且能够执行硬件直接支持的指令集格式。

​	Java虚拟机规范定义了字节码执行引擎的概念模型，这个模型成为虚拟机执行引擎的统一外观。在不同虚拟机实现中，执行引擎在执行Java代码时可能有解释执行（解释器执行）和编译执行（即时编译器产生本地代码执行）两种选择，也可以两者兼备，甚至还可以包含几个不同级别的编译器执行引擎。但从外观上，所有的Java虚拟机执行引擎都是一样的，输入字节码文件，处理过程是字节码解析的等效过程，输出执行结果。

### 2. 运行时帧结构

​	栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息，每一个方法从调用开始到执行完成就是一个栈帧在虚拟机栈从入栈到出栈的过程。

​	每一个栈帧都包含局部变量表、操作数栈、动态连接、方法返回地址和额外附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈已经完全确定了，并且写入方法表的Code属性中，因此一个栈帧的内存分配不会受程序运行期变量数据的影响，而仅仅取决于虚拟机的实现。

​	一个线程中的方法调用链可能会很长，很多方法都处于执行状态。对于执行引擎，在活动线程中，只有位于**栈顶的栈帧才有效**，称为当前栈帧（Current Stack Frame），这个栈帧对应的方法称为当前方法，执行引擎运行的字节码指令都是针对当前栈帧操作的。

![img](https://img-blog.csdn.net/20141214124019390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHRheWZqcGs=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center) 

* 局部变量表
  * 局部变量表（Local Variable Table）是一组变量值存储空间，用于存储方法参数和方法内部定义的局部变量。在Java程序编译成Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法内部所需要分配的局部变量表的最大容量。
  * 局部变量表的容量以变量槽（Variable Slot）为最小单位，虚拟机规范中没有明确指定Slot占用的内存大小，只是导向性的说每个Slot应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或者更小的物理内存来存放，但不是表示Slot占用32位字节，它允许Slot随处理器、操作系统或虚拟机的不同而灵活变化，64位虚拟机实现的Slot，采用对齐和补白的手段，保证让Slot在外观看起来与32位虚拟机中一致。
  * 虚拟机通过索引定位的方式使用局部变量表，索引值的范围从0开始至局部变量表最大的Slot数量。如果访问的是32位的数据类型变量，索引n表示第n个Slot，如果是64位，则同时使用n和n+1的Slot。对于相邻的Slot同时表示一个64位数据类型变量，不允许采用任何方式访问其中一个，Java虚拟机规范中明确要求如果遇到这种操作的序列，在类加载的校验阶段抛出异常。
  * 在方法执行时，虚拟机使用局部变量表完成参数值到参数变量列表的传递过程，如果执行的是实例方法，局部变量表的第0位索引的Slot默认是用于传递方法所属类实例的引用，可以通过this访问这个隐含参数。其余参数按参数表顺序排列，从索引1开始。
  * 为了节省栈空间，Slot是可以复用的，方法体中定义的局部变量其作用域并不一定覆盖整个方法体，如果当前字节码PC计数器的值超过某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用。
  * **局部变量定义了但没有赋初始值是不能使用的**。

* 操作数栈

  * 操作数栈（Operand Stack）也称为操作栈，它是先入后出的栈。同局部变量一样，操作栈的最大深度在编译的时候已经写入到Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。32位数据类型占栈容量的1，64占2，在方法执行的任何时候，操作数栈的深度不会超过在max_stacks数据项中设定的最大值。
  * 当一个方法刚开始执行的时候，操作数栈是空的，在方法执行过程中，各种字节码指令往操作数栈中写入或读取内容，也是出/入栈的操作。
  * 在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。但是在大多数虚拟机实现中都做了一些优化，令两个栈帧有部分区域重叠，这样方法调用可以调用公用区域，无需额外的参数复制传递。

* 动态连接

  * 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。
  * 这些符号引用在一部分在类加载阶段或者第一次使用时候就转化为直接引用，这种转化称为静态解析。另一部分在每次运行期间转化为直接引用，这部分称为动态连接。

* 方法返回地址

  ​		当方法开始执行后，有两种方式退出该方法。

  * 第一种是遇到任意一个方法返回的字节码指令，这时会有返回值传递给上层的调用者，是否有返回值取决于方法是那种方法返回指令，这种退出方式称为正常完成出口。

  * 另一个方式是方法执行过程中遇到异常，并且这个异常在方法体内没有处理，这是无论是虚拟机内部产生的异常还是代码使用字节码athrow产生的异常，只要在方法体没有匹配到异常处理器，就会导致方法退出，这种退出称为异常完成出口。一个方法异常返回是不会给调用者任何返回值的。

    ​	无论以何种方式退出，方法退出之后都需要返回到方法被调用位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来恢复它的上层方法的执行状态。一般来说，方法正常退出，程序计数器的值可以作为返回地址，栈帧中可能保存计数器值；而方法异常退出，返回地址需要通过异常处理器表来确定，栈帧一般不会保存这部分信息。

    ​	方法退出实际等于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量和操作数栈，把返回值（如果有）压入调用者栈帧的操作数栈，调整PC计数器的值以指向方法调用指令的下一条指令。

* 附加信息

  ​	虚拟机规范允许具体的虚拟机实现增加一些规范没有描述的信息到栈帧中，例如与调试相关的信息，这部分完全取决于虚拟机的实现。实际开发中，一般把动态连接，方法返回值地址，附件信息统称为栈帧信息。

### 3.方法调用

​	方法调用不等于方法执行，方法调用的唯一任务是确定被调用方法的版本（即调用哪一个方法），暂时不涉及方法内部的具体运行过程。在程序运行时，方法调用是最普遍，最频繁的操作，Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局的入口地址（直接引用）。这个特性给Java带来了更强大的动态扩展能力，但也是Java的方法调用变的复杂，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。

#### 解析

​	所有方法调用的目标方法在Class文件中都是一个在常量池的符号引用，在类加载解析阶段，将其中一部分转化为直接引用，这种解析的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个版本在运行期间不会改变。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析。

​	在Java语言中符合“编译器可知，运行期不可变”的方法，主要是静态方法和私有方法，前者与类直接关联，后者在外部不可访问，这两类方法各自的特点决定他们不能通过继承或别的方式重写方法版本，因此都适合在类加载时解析。与之对应的，Java虚拟机提供了5个方法调用字节码指令，分别如下：

* invokestatic：调用静态方法。

* invokespecial：调用实例构造器<init>()方法，私有方法和父类方法。

* invokevirtual：调用虚方法。

* invokeinterface：调用接口方法，会在运行时确定一个实现此接口的对象。

* invokedynamic：在运行时动态解析出调用点限定符所引用的方法，然后执行。

  解析调用一定是静态操作，在编译期间就完全确定，在类加载器的解析阶段就会把涉及到的符号引用全部转化为可确定的直接引用，不会延时到运行期完成。

#### 分派

​	解析是静态的，而分派则可能是静态的也可能是动态的，根据分派依据的宗量数可分为单分派和多分派。这两个分派方法两两组合就构成了静态单分派、静态多分派、动态单分派和动态多分派。

​	Java是面向对象语言，是因为Java具备面向对象的3个基本特征：封装、继承和多态。分派调用过程是多态特性的基本体现，如“重写”，“重载”。

* 静态分派。
  * 静态类型和实际类型都可以在运行时发生变化，区别时静态类型的变化只在使用时发生，变量本身的静态类型不会发生变化，并且最终的静态类型是在编译器期可知的；而实际类型的变化的结果在运行时才知道，编译器在编译时不知道对象的实际类型。
  * 所有依赖静态类型来定位方法执行版本的分派方式称为静态分派。静态分派的典型应用就是方法重载，静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。编译器虽然能确定出方法的重载版本，但是很多情况下方法的重载版本并不是“唯一的”，往往只能确定"更适合" 的版本。
* 动态分派。动态分派的应用是方法重写。

#### 动态类型语言支持

​	JDK1.7中引入了新的字节码指令invokedynamic指令。这条指令是JDK7实现“动态类型语言”支持而进行的改进之一，也是JDK1.8可以顺利实现lambda的基础。

* 动态类型语言的关键特征是它的类型检查主体过程是在运行期而不是编译期，例如：APL、Erlang、JavaScript、Lua、Python、PHP、Ruby等语言，相对的静态类型语言如C++/Java。动态类型语言与动态语言、弱类型语言不是一个概念。

### 4.基于栈的字节码解释执行引擎

* 解释执行
  * Java语言，javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码执行流的过程。这一部分是在Java虚拟机之外进行的，而解释器在虚拟机内部，所以Java程序的编译时半独立的实现。
* 基于栈的指令集与基于寄存器的指令集
  * Java编译器输出的指令流，基本是基于栈的指令集架构（Instrunction Set Architecture,ISA），指令流中的指令大部分都是零地址指令，它们依赖操作数栈进行工作。
  * 另一套常用的指令集是基于寄存器架构的，最典型的额是x86的二进制地址指令集，也就是现在PC机直接支持的指令集架构，这些指令依赖于寄存器工作。
  * 栈架构指令集执行速度相对较慢，虽然代码紧凑，但完成相同功能的指令数量一般比寄存器架构多，因为入栈、出栈操作本身就会产生很多指令。更重要的是栈实现在内存中，频繁的栈访问意味着频繁的内存操作，相对于处理器来说，内存始终是执行速度的瓶颈。尽管虚拟机可以采取栈顶缓存的手段，把最常用的操作映射到寄存器中避免直接访问内存，但这只是优化而不是解决问题的本质方法。由于指令数量和内存访问导致栈架构指令集的执行速度会相对较慢。
* 基于栈的解释器执行过程

## 九、程序编译与代码优化

### 1.早期（编译期）优化

#### 概念

​	Java语言的编译期是一段不确定的操作过程，它可能指编译器前端，把.java文件转为.class文件的过程；也可能是虚拟机的后端运行期编译器（JIT编译器）把字节码转为机器码的过程；还可能是指使用静态提前编译器（AOT编译器），直接把.java文件编译成本地机器代码的过程。

#### Javac编译器

​	从Sun Javac来看，编译过程分为3个过程，分别是解析与填充符号表，插入式注解处理器的注解处理，分析与字节码生成等过程。javac编译动作的入口是`com.sun.tools.javac.main.JavaCompiler`类，整个编译过程最关键的步骤如下图所示：

![Javacç¼è¯è¿ç¨.png](https://github.com/gnng/bookList/blob/master/image/Javac%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png?raw=true) 

##### 解析与填充符号表

* 词法、语法分析。
  * 词法分析是将源代码字节流转化为标记（Token）集合，单个字符是程序编写过程中最小元素，而标记时编译过程的最小元素，关键字、变量名、运算符、字面量都可以成为标记。比如`int a = b+2`包含6个标记，int虽然由3个字符组成，但是它是一个Token，不可再分。在javac源码中，词法分析的过程是由`com.sun.tools.javac.parser.Scanner`类来实现。
  * 语法分析是通过Token序列构造抽象语法树的过程，抽象语法树是用来描述程序代码语法结构的树形表示方式，语法树上的每一个节点代表程序代码中的一个语法结构，例如包、类型、修饰符、运算符、接口、返回值甚至是代码注释等都可以是一个语法结构。
* 填充符号表
  * 完成语法和词法分析后下一步是填充符号表的过程，符号表是由一组符号地址和符号信息构成的表格，可以理解为哈希表的K-V形式（实际上符号表不一定是哈希实现，可能是有序符号表、树状符号表、栈结构符号表等）。
  * 符号表中所登记的信息在编译的不同阶段都会用到。在语义分析中，符号表登记的信息将用于语义检查和产生中间代码。在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。

##### 注解处理器

* JDK1.5之后提供了对注解的支持，与普通代码一样在运行时发挥作用。在JDK1.6中实现了JSR-268规范，提供了一组插入式注解处理器的标准API，在编译期对注解进行处理，可以看做是一组编译器插件，可以读取、修改、添加抽象语法树的任意元素。如果这些插件在处理注解期间对编译期的语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器没有对语法树修改，每次循环称为Round回环。
* 有了编译器注解处理的标准API，代码才有可能干预编译器的行为，由于语法树中的任意元素，包括代码注释都可以在插件中获取，所以通过插入式注解处理器实现的插件可以有很大的发挥空间。

##### 语义分析与字节码生成

​	语法分析之后，编译器获得了程序代码的抽象语法树，语法树能够表示一个正确的源程序抽象，但是无法保证源程序是否符合逻辑。而语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如类型审查。

​	语义分析过程中分为标注检查和数据及控制流分析两个步骤：

* 标注检查，检查的内容包括变量使用前是否被声明，变量与赋值的数据类型是否匹配等。
* 数据及控制流分析，是对程序上线文逻辑更进一步的验证，可以检查出局部变量使用前是否赋值、方法的每条路径是否有返回值、是否所有受检查异常都正确处理等问题。编译期的数据及控制流分析与类加载是的分析目的一致，但校验范围有所区别，有一些校验只有在编译期或运行期才能进行。
* 解语法糖。语法糖也称糖衣语法，指在程序中添加某种语法，对程序功能没有影响，只是方便程序员使用。使用语法糖可以增加代码可读性，减少代码出错机会。
* 字节码生成，是javac最后一个阶段，字节码生成阶段不仅把各步骤生成的信息（语法树，符号表）转为字节码写入磁盘中，编译器还进行了少量代码添加和转换工作。

#### Java语法糖

* 泛型与类型擦除。
  * 泛型是JDK1.5新增的特性，它的本质是参数化类型的应用，也就是所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。
  * Java语言中，泛型只在源码中存在，编译后的字节码文件就已经替换成原来的原生类型（Raw Type，也称裸类型），并且在相应的地方插入了强制转型代码。
  * 泛型技术实际上是Java的一个语法糖，Java语言中的泛型实现方式称为类型擦除，这种实现泛型的方式称为伪泛型。
  * 类型擦除，所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还保留了泛型信息，这也是通过反射手段获取参数化类型的根本依据。
* 自动拆箱、装箱和遍历循环
  * 自动拆、装箱在编译之后被转化为对应的包装和还原方法。
  * 遍历循环则把代码还原成了迭代器的实现，这也是遍历循环需要被遍历的类实现Iterable接口的原因。
  * 变长参数，它在调用的时候变成了一个数组类型的参数。
* 条件编译
  * 许多程序设计语言都提供了条件编译的途径，如C、C++中使用预处理器指示符（#ifdef）来完成条件编译。而Java语言没有使用预处理器，Java语言是天然的编译方式，无需使用预处理器。
  * Java语言使用条件编译就是使用条件为常量的if语句。例如if(true){}。

#### 插入式注解处理器

### 2.晚期（运行期）优化

#### 概述

* 在部分商用虚拟机（Sun HotSpot）中，Java程序最初是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这块代码认定为“热点代码”。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成本地执行的机器代码，并进行各个层次的优化，完成这个任务的编译器叫即时编译器（Just In Time Compiler，JIT编译器）。
* 即时编译器并不是虚拟机所必要的部分，JVM规范中更没有限定和指导JIT的具体实现。但是JIT编译性能的好坏、优化代码程度的高低是衡量Java虚拟机实现优秀与否的关键指标。

#### HotSpot虚拟机内的即时编译器

##### 解释器与编译器

* 解释器与编译器两者各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去了编译时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，提高了执行效率。当程序运行环境中内存资源限制较大（部分嵌入式系统）时，可以使用解释执行节约内存，用编译执行提高效率。
* 解释器还可以作为编译器激进优化时的“逃生门”，让编译器根据概率选择一些代码，大多数时候都能提升运行速度，当激进优化的假设不成立时，如加载了新类后类型继承结构出现变化、出现"罕见陷阱"时可以通过逆优化退回到解释状态继续执行，因此在整个虚拟机架构中，解释器和编译器相互配合工作。
* HotSpot提供了两个即时编译器，Client Compiler和Server Compiler，简称为C1和C2编译器也叫Opto编译器。解释与编译器搭配使用的方式在虚拟机中称为“混合模式”，用户可以通过`-Xint`参数强制虚拟机运行于解释模式，`-Xcomp`强制使用编译模式。
* 由于编译器编译本地代码需要占用程序运行时间，要编译出优化更高的代码，花费时间可能更长；而编译优化更高的代码，解释器可能还要替编译器收集性能监控信息，这影响了解释执行的速度。为了在程序启动响应速度与运行效率之间达到平衡，HopSpot逐渐使用分层编译的策略，JDK1.7的Server模式下默认开启。
  * 第0层，程序解释执行，解释器不开启性能监控，可触发第1层编译。
  * 第1层，也称C1编译，将字节码编译为本地代码，进行简单、可靠的优化，如有必要加入性能监控的逻辑。
  * 第2层（或2层以上），也称C2编译，将字节码编译为本地代码，会启用一些编译耗时较长的优化，甚至根据性能监控信息进行不可靠的激进优化。

##### 编译对象与触发条件

* 运行过程中会被即时编译器编译的代码为“热点代码”，热点代码有两类：
  * 被多次调用的方法。
  * 被多次执行的循环体。尽管编译动作是由循环体触发，但是编译器依然会以整个方法（不是循环体）作为编译对象。这种编译方式因为编译在方法执行过程中，所以称为栈上替换，简称OSR编译，即方法栈帧还在栈上，方法就被替换了。

* 判断一段代码是不是“热点代码”，是不是需要即时编译，这样的行为称为热点探测（Hot Spot Detection），其实热点探测并不知道方法具体被调用了多少次，目前主要热点探测有两种：

  * 基于采样的热点探测（Sample Based Hot Spot Detection）：采用这种方法的虚拟机会周期性检查各个线程的栈顶，如果发现某个或某些方法经常出现在栈顶，那么这个方法就是“热点方法”。好处是实现简单、高效还可以获取方法调用关系，缺点是很难精确某个方法的热度，容易受线程阻塞或其他的外部因素影响热点探测。

  * 基于计数器的热点探测（Counter Based Hot Spot Detection）：采用这个方法的虚拟机会为每个方法或代码块建立一个计数器，统计方法的执行次数，如果执行次数超过某个阈值，判定为“热点方法”。这种方式实现相对麻烦，不能直接获取方法调用关系，但是它的统计结果相对准确和严谨。

  * HotSpot默认采用计数器的热点探测，它为每个方法提供两个计数器：方法调用计数器和回边计数器。在确定虚拟机运行参数的情况下，这两个计数器的阈值已经确定，当计数器数超过阈值溢出，就会触发JIT。

    * 方法调用计数器，统计的并不是方法被调用的绝对次数，而是相对的执行频率，即一段时间内方法的调用次数。当超过一定的时间限度，如果方法的调用次数仍不足以让它提交到即时编译器编译，那这个方法的调用计数器就会减半，这个过程称为方法调用计数器的热度衰减，这段时间称为此方法统计的半衰周期。进行热度衰减的动作是在垃圾收集的时候顺带进行的，可以通过参数`-XX:-UseCounterDecay`来关闭热度衰减。

      ![æ¹æ³è°ç¨è®¡æ°å¨è§¦åå³æ¶ç¼è¯.png](https://github.com/gnng/bookList/blob/master/image/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A7%A6%E5%8F%91%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91.png?raw=true) 

    * 回边计数器，是统计一个方法中循环体代码的执行次数，在字节码中遇到字节码向后跳转的指令称为回边，回边计数器统计的目的是为了触发OSR编译。回边计数器没有热度衰减的过程，因此计数器记录的就是方法循环执行的绝对次数。

      ![åè¾¹è®¡æ°å¨è§¦åå³æ¶ç¼è¯.png](https://github.com/gnng/bookList/blob/master/image/%E5%9B%9E%E8%BE%B9%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A7%A6%E5%8F%91%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91.png?raw=true) 

##### 编译过程

​	在默认设置下，无论是方法调用产生的即时编译请求还是OSR编译请求，虚拟机在代码编译器还未完成之前都会按照解释方式继续执行，而编译动作则在后台的编译线程中执行。用户可以通过参数`-XX:-BackgroundCompilation`来禁止后台编译，在禁止后台编译之后，一旦达到JIT编译条件，执行线程向虚拟机提交编译请求后将一直等待，直到编译过程完成后再开始执行编译器输出的本地代码。

* C1和C2两个编译器编译过程不同，对C1来说，它是一个简单快速的三段式编译器，关注点在局部性的优化，放弃了耗时较长的全局优化手段。
  * 第一阶段，一个平台构建的前端将字节码构造成一种高级中间代码表示（HIR）,HIR使用静态单分配的形式来表示代码值。在此之前编译器会对字节码进行基础优化，如方法内联、常量传播等优化将在字节码被构造成HIR之前完成。

  * 第二阶段，一个平台相关的后端从HIR中产生低级中间代码表示（LIR），而在此之前会在HIR上完成另外的优化，例如：空值检查消除、范围检查消除等，以便让HIR达到更高效的代码表现形式。

  * 最后阶段是在平台相关的后端采用线性扫描算法，在LIR上分配寄存器，并在LIR上做窥孔优化，然后产生机器代码。

    ![Client Compoleræ¶æ.png](https://github.com/gnng/bookList/blob/master/image/Client%20Compoler%E6%9E%B6%E6%9E%84.png?raw=true) 

* C2则是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，也是充分优化过的高级编译器，它会执行所有经典的优化操作，如无用代码消除、循环展开、循环表达式外提、消除公共子表达式、常量传播、基本块重排序等，还会实施一些与Java密切相关的优化措施，如范围检查消除、空值检查消除（并非所有的空值消除都是有编译器优化的，有些代码运行过程中自动优化）等。

##### 查看和分析即时编译结果

​	一般来说，虚拟机的即时编译过程对用户是完全透明的，虚拟机不管通过解释执行代码还是编译执行代码，对用户来说是没有影响的（执行结果没影响，速度上会有很大差别），大多数情况下用户也没必要知道。但是虚拟机也提供了一些参数来输出即时编译和某些优化手段的执行状况。

#### 编译优化技术

##### 优化技术概述

​	HotSpot列出了相对全面的，在即时编译器中才有的优化技术列表，包含经典编译器的优化手段和针对运行在Java虚拟机上的所有语言本身进行的技术优化。

* 第一步进行方法内联，两个目的，一是去除方法调用的成本，二是为其他优化建立基础。优化序列最靠前。

* 第二步是冗余访问消除，或者是公共子表达式消除。例：

  ```java
  x = a.value();
  y = a.value();
  // 优化后为
  y = x;
  ```

* 第三步是复写传播。上面代码没必要新增变量y，可以直接通过x进行操作。

* 第四步是无用代码消除。省略没有意义的代码。

##### 公共子表达式消除

* 普遍应用于各种编译器的经典优化技术，含义：如果一个表达式E已经计算过，并且先前的计算到现在E中的变量值都没有发生变化，那么E的这次出现就成为了公共子表达式。对于这种表达式，使用时没必要重新计算，直接用之前计算过的结果替换E即可。
* 如果这种优化仅限于程序的基本块中，称为局部公共子表达式消除；如果覆盖多个基本块，称为全局公共子表达式消除。

##### 数组边界检查消除

* 数组边界检查消除是即时编译器中的一项语言相关的经典优化技术。Java是一门安全语言，对数组的读写不像C/C++那样本质是裸指针操作。在Java语言中访问数组的时候，系统将会自动进行上下界的范围检查，超出边界则抛出异常。
* 以foo[3]为例，通过数据流分析确定foo.length的值，并判断"3"没有越界，执行的时候就不用判断了；在循环中访问数组时，如果编译器通过数据流分析可以判定循环变量的取值永远在[0,foo.length)之内，那么整个循环中，可以把数组的上下界检查消除。

##### 方法内联

* 方法内联的优化是其他一系列优化的基础。
* 方法内联看起来很简单，不过是把目标方法的代码“复制”到发起调用的方法中，避免发生真实的方法调用。实际Java虚拟机的内联很复杂，即时编译器做了很多努力，否则大多数Java方法无法内联。
* 私有方法、实例构造器、父类方法和静态方法是在编译期进行解析的，其他的Java方法是在运行时多态选择的（final修饰的方法除外），Java语言默认的实例方法为虚方法。
* 为了解决虚方法的内联关系，引入了“类型继承关系分析”（CHA）的技术，这是基于整个应用程序的类型分析技术，用于确定目前已加载的类中，某个接口是否有多种实现，某个类是否存在子类，子类是否为抽象类等。
* 内联过程：
  * 编译器进行内联时，不是虚方法直接内联；
  * 如果是虚方法，向CHA查询此方法在当前程序下是否有多个目标版本可供选择。
    * 如果查询结果只有一个版本，则可以内联，这种内联属于激进优化，需要预留“逃生门”，称为守护内联。
      * 如果程序后续执行过程中，这个方法的继承关系没有发生变化，则内联优化的代码继续执行下去。
      * 如果加载了导致继承关系发生变化的新类，就抛弃已经编译的代码，退回解释状态执行，或者重新编译。
    * 如果有多个版本可以选择，编译器会进行最后努力，使用内联缓存来完成方法内联。这是一个建立在目标方法正常入口之前的缓存，原理：在未发生方法调用之前，内联缓存状态为空，当第一次发生调用，缓存记录方法接收者的版本信息，并且每次调用时都比较接收者版本。
      * 如果每次调用的接收者版本都一样，则内联可以继续下去。
      * 如果发生方法接收者不一致，说明程序使用了虚方法的多态特性，取消内联，查出虚方法表进行方法分派。

#####  逃逸分析

​	逃逸分析是目前Java虚拟机比较前沿的优化技术，它与类型继承关系分析一样，并不是直接有话啊代码的手段，而是为其他优化手段提供依据的分析技术。

​	逃逸分析的基本行为就是分析对象的动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到别的方法中，称为方法逃逸。还可能被外部线程访问到，如赋值给类变量或可以在其他线程内部访问实例变量，称为线程逃逸。

​	如果能证明一个对象不会发生逃逸，也就是别的方法或线程无法通过任何途径访问这个对象，可以对这个对象高度优化，例：

* 栈上分配：Java虚拟机中，创建的对象都是在堆中分配，对其他线程共享，只要持有该对象的引用，就可以访问堆中存储的数据。虚拟机可回收堆中不再使用的对象，但无论是筛选对象还是回收整理内存都是需要耗费时间的，如果一个对象不会发生逃逸，那么可以让这个对象在栈上分配，对象占用的内存空间可以随栈帧出栈销毁。
* 同步消除：线程同步本身就是相当耗时的，如果逃逸分析可以确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定不会有竞争，这个变量的同步措施可以消除。
* 标量替换：标量是指一个数据已经无法再分解成更小的数据来表示，Java的原始数据类型都不能进一步分解，他们都是标量。相对的，如果一个变量可以分解，这个变量称为聚合量，对象是最典型的聚合量。如果把一个对象拆散，根据程序访问情况，将其使用到的成员变量恢复原始数据来访问就是标量替换。如果一个对象通过逃逸分析确定不会被外部访问，并且这个对象可以被拆解，那么程序执行的时候可能不创建这个对象，而直接创建它的若干个被这个方法使用的成员变量来代替。将对象拆散后，除了可以让对象的成员变量在栈上分配（栈上存储的数据，很大的概率会被虚拟机分配至物理机器的高速寄存器上存储）和读写外，还可以为后续的优化创建条件。

## 十、并发优化

### 概述

​	衡量一个服务性能的高低好坏，每秒事务处理数（TPS），是重要指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS值与程序的的并发能力有密切关系。对于计算量相同的任务，程序线程并发协调得越有条不紊，效率越高；反之，线程之间频繁阻塞甚至死锁，将会大大降低程序的并发能力。

### 硬件的效率与一致性

* 绝大多数的运算任务是处理器与内存交互完成的，如读取运行数据、存储运算结果，这个I/O很难消除（无法仅靠寄存器完成所有运算任务）。由于计算器的存储设备和处理器运算速度的差距，现代计算机引入了一层读写速度接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运行需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存中，这样处理器就无需等待缓慢的内存读写了。

* 基于高速缓存，可以很好解决读写缓慢问题，但是引入了新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享主内存（Main Memory），当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存不一致。为了解决一致性问题，各个处理器访问缓存时都要遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI、MOSI、Synapse、Firefly及Dragon Protocol等。

  ![img](http://s1.knowsky.com/20170221/tzahgjdwygy23.png) 

* 除了增加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序结果重组，保证该结果与顺序执行结果一致，但并不保证程序中各个语句计算的先后顺序与输入代码顺序一致，因此，如果存在一个计算任务依赖另一个计算任务结果，那么其顺序性无法通过代码顺序保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器也有类似的指令重排优化。

### Java内存模型

​	Java虚拟机规范试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽硬件和操作系统对内存操作的差异，以实现Java程序在各种平台上都有一致的内存访问效果。经过长时间的验证和修补，在JDK1.5(JSR-133)发布之后，JMM已经成熟和完善。

#### 主内存和工作内存

* JMM的主要目标是定义程序各个变量的访问规则，即在虚拟机中将变量存储到主内存和从主内存取出变量的底层细节。此处的变量包括实例字段、静态字段和构成数组的元素，但不包含局部变量和方法参数，后者是线程私有的，不会共享，不存储线程安全问题。
* 为了获得较高的执行效率，JMM没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译对代码顺序的调整。
* JMM规定所有的变量都存储在主内存中，没个线程都有自己的工作内存，线程的工作内存保存了该线程使用到的变量的内存副本拷贝，线程对变量的所有操作都是在工作内存中完成，不能直接读写主内存的变量。不同线程直接无法直接访问彼此的工作内存中的变量，线程间通讯需要通过操作主内存完成。

#### 工作内存交互操作

* 一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存，JMM定义了8种操作，虚拟机实现时必须保证下面提及的操作都是原子的、不可再分的（对于double和long类型的变量，load,store,read和write操作在某些平台上允许例外）：
  * lock（锁定）：作用于主内存的变量，它把变量标识为一条线程独占状态。
  * unlock（解锁）：作用于主内存变量，把处于锁状态的变量释放出来，释放后的变量才能被其他线程锁定。
  * read（读取）：作用于主内存变量，把一个变量的值从主内存中传递到线程的工作内存。
  * load（载入）：作用于工作内存变量，把read操作得到的变量加载到工作内存的变量副本中。
  * use（使用）：作用于工作内存变量，把工作内存的变量传递给执行引擎，每当虚拟机遇到一个需要使用到变量的字节码指令时将会执行这个操作。
  * assign（赋值）：作用于工作内存变量，把从执行引擎接收到的值赋给工作内存的变量，当虚拟机遇到一个给变量赋值的字节码指令会执行这个操作。
  * store（存储）：作用于工作内存变量，它把工作内存的变量的值传递到主内存中，以便随后的write操作使用。
  * write（写入）：作用于主内存变量，它把store操作的变量放入主内存变量中。
* 如果将主内存变量复制到工作内存中，要顺序执行read和load操作，如果把工作变量同步到主内存中，要顺序执行store和write操作，JMM要求上述两个操作必须按顺序执行，但没有保证连续执行，也就是read和load之间，store和write操作之间可以插入其他命令。除此之外，JMM规定了执行以上8种操作必须满足如下规则：
  * 不允许read和load，store和write操作之一单独执行，即不允许一个变量从主内存读取但工作内存不接受，或者从工作内存发起回写但主内存不接受的情况出现。
  * 不运行一个线程丢弃它最近的assign操作，即变量在工作内存中改变之后必须把该变量同步到主内存。
  * 不允许一个线程无缘无故（没有发生任何assign操作）把工作内存的变量同步回主内存。
  * 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，也就是说user，store操作之前必须先执行过load和assign操作。
  * 一个变量同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock，变量才会被解锁。
  * 如果一个变量执行了lock操作，将会清空工作内存的变量值，在执行引擎使用这个变量前，需重新执行load和assign操作初始化变量的值。
  * 如果一个变量事先没有被lock操作锁定，那就不允许执行unlock操作，也不允许unlock一个其他线程锁定的变量。
  * 对一个变量执行unlock之前，必须先把变量同步回主内存中（执行store和write操作）。
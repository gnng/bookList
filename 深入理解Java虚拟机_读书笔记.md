## 一、自动内存管理机制

### 1. Java内存区域

* 程序计数器
  * **较小**的一块内存**空间**，可以看做是**当前线程**执行的字节码的**行号指示器**。**字节码解释器工作时就是通过改变这个计数器的值来取下一条需要执行的字节码指令**，分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。
  * 如果线程正在执行的是Java方法，计数器存储的是当前执行字节码指令地址；如果执行的本地方法（Native），这个计数器值为空（Undefined）。
  * 此区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
* Java虚拟机栈
  * 线程私有，生命周期与线程相同。
  * 描述Java方法执行的内存模型，每个方法执行的时候都会创建一个**栈帧**，用于存储**局部变量表、操作数栈、动态链接、方法出入口**等信息。每一个方法从调用到执行完成都对应一个栈帧在虚拟机栈中从入栈到出栈的过程。
  * 局部变量表存放的是编译期可知的基本数据类型（3类8种），对象引用类型。
  * 64位长度的long和double类型的数据占2个局部变量空间（slot）,其余的数据类型占1个。
  * 此区域规定了两种异常状况：如果线程请求栈深度大于虚拟机所允许栈深度，抛出StackOverFlowError异常；如果虚拟机栈可以动态扩展（当前大部分Java虚拟机都可动态扩展），如果扩展时无法申请到足够内存，抛出OutOfMemoryError异常。
* 本地方法栈
  * 与虚拟机栈类似，区别是Java虚拟机栈执行的是Java方法（字节码），本地方法栈执行的是本地方法（Native修饰的方法）。
  * 有的虚拟机讲本地方法栈和虚拟机栈合二为一。
  * 本地方法栈也会抛出StackOverFlowError和OutOfMemoryError异常。
* Java堆
  * Java虚拟机所管理的内存中最大的一块区域，被**所有线程共享**，在虚拟机启动时创建。
  * 唯一目的，存入Java对象实例。分配大部分实例（JIT编译器的发展与逃逸分析技术的成熟，栈上分配、标量替换优化技术）。
  * Java堆是垃圾收集器管理的主要区域。
    * 从内存回收的角度，由于现在收集器基本都是采用分代收集算法，所以Java堆还可以细分为：新生代和老年代，再细分Eden空间、From Survivor空间和To Survivor空间等；
    * 从内存分配角度，线程共享的Java堆中可能划分出多个**线程私有的分配缓冲区（Thread Loacl Allocation Buffer TLAB）**;
  * 根据Java虚拟机规范，Java堆可以处理物理上不连续的内存空间，只要逻辑上连续即可，类似于磁盘空间。在实现时，既可以固定大小，也可以动态扩展（通过-Xmx和-Xms控制）。
* 方法区
  * 所有线程共享，存储被虚拟机加载的**类信息、常量、静态变量、即时编译器编译后的代码**等数据。
* 运行时常量池
  * 运行时常量池是方法区的一部分。
  * Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池。
  * 可能抛出OutOfMemoryError异常。
* 直接内存
  * 直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是被频繁使用。
  * JDK1.4引入的NIO（new input/output）类，引入了一种基于管道和缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作（避免Java堆和Native堆来回复制数据）。

### 2. 对象管理

* 对象的创建
  * 检测是否被加载过。当虚拟机遇到一条new指令时，首先检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用对应的类是否已被加载、解析和初始化。如果没有，先执行类加载过程。
  * 对象内存分配。类加载检查通过后，虚拟机会新生对象分配内存。对象所需内存大小在类加载完成后便可完全确定，为对象分配内存的过程相当于在Java堆中为对象划出一块大小确定的区域。
    * 堆内存规整，所有用过的内存在一边，另一边是空闲内存，中间存放一个指针作为分界点的指示器，所分配内存就是把指针向空闲区域移动一段对象大小相等的区域，称为“指针碰撞”。
    * 堆内存不规整，已使用的内存和空闲内存相互交错，没办法简单的指针碰撞，虚拟机必须维护一个列表，记录哪块内存可用，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。
    * 哪种方式分配取决于堆内存是否规整，堆是否规整又取决于所采用的垃圾回收器是否带有压缩整理功能。因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的收集算法是指针碰撞；而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。
  * 分配过程中的问题，指针的分配是线程不安全的。除了要考虑可用空间的划分之外，还需要考虑对象创建在虚拟机中是否为非常频繁的行为。即使仅仅修改一个指针所指向的位置，在并发情况下也不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针分配了内存。解决该问题有两种方案：
    * 分配内存空间的动作进行同步处理——实际上虚拟机采用的是CAS加上失败后重试的方式保证更新操作的原子性。
    * 把内存的分配动作按线程划分到不同空间中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Loacl Allocation Buffer,TLAB）。哪个线程要分配内存就在哪个线程的TLAB上分配，只有TLAB用完并且要分配新的TLAB时，才需要同步操作。虚拟机设置是否使用TLAB,可以通过参数-XX:+/-UseTLAB参数来设定。
  * 内存初始化，不包含对象头。内存分配完成之后，虚拟机需要将分配的内存初始化为零值（不包含对象头），如果使用TLAB，这一操作可以提前至TLAB分配时进行。这一操作，保证了对象的实例字段在java代码中不赋初始值也可以直接使用，程序能访问这些字段的数据类型所对应的零值。
  * 设置对象头。设置该对象属于哪个类、如何才能找到类的元数据信息（描述程序过程的数据）、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象头中（Object Header）。根据虚拟机当前运行状态不同，如是否启用偏向锁等，对象头会有不同的设置方式。
  * Java程序角度初始化。在虚拟机的角度，新的对象已经产生，但是从Java程序的角度来看，对象的创建才刚刚开始——还没有执行<init>方法，所有的字段都为零。一般来说，执行完new指令后会接着执行init方法，把对象按照程序员的意愿进行初始化，这样真正可用的对象才算完全创建出来。

* 对象的布局

  在HotSpot虚拟机中，对象的内存布局分为三个区域，对象头（Header）、实例数据（Instance data）和对齐填充（Padding）。

  * 对象头包含两部分：
    * 第一部分储存对象自身运行时的数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据长度32bit/64bit(32位/64位操作系统)，官方称为“Mark Word”。对象需要存储的运行时数据会很多，远远超过32位或64位bitmap结构所能记录的限度，所以为考虑虚拟机空间效率，Mark Word设计为非固定的数据结构，以便在极小的空间内存存储尽量多的信息。
    * 另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机可以通过这个指针确定该对象所有哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保存类型指针，换句话说，查找对象的元数据信息不一定要通过对象本身。
    * 如果对象是一个数组，那么对象头中必须有一块用于记录数组长度的数据。因为虚拟机可以通过普通对象的元数据信息知道对象的大小，而数组的元数据中不能确定数组的大小。
  * 实例数据。实例数据是对象真正存储的有效信息，也是程序代码中定义的各种类型字段的内容。无论是从父类继承下来，还是子类中定义的，都要记录下来。这部分存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义的顺序影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers）,从分配策略可以看出相同宽度的字段总是被分配在一起。在满足这个前提下，父类中定义的变量会出现在子类之前，如果CompactFields参数为true（默认为true）,子类中较窄的变量也可能插入到父类变量的空隙中。
  * 对齐填充。该部分并不是必然存在，也没有特别含义，仅起到占位符的作用。由于HotSpot VM的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，也就是对象的大小必须是8字节的整数倍，而对象头的大小正好是8字节的整数倍（1倍或2倍），因此当对象实例数据部分没有对齐时，就需要对齐填充来补全。

* 对象的使用。建立对象是为了使用对象，Java程序需要通过栈上的reference数据来操作堆上的具体对象。有用reference类型在虚拟机规范中只规定了一个对象的引用，并没有定义这个引入应该通过何种方式，访问堆中对象的具体地址，所以对象访问方式由虚拟机实现决定。目前主流采用句柄和直接引用两种。

  * 句柄。如果使用句柄访问，在Java堆中会划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中又包含了对象的实例数据（堆）和类型数据（方法区）各自的具体地址信息。

    ![img](http://img.mp.itc.cn/upload/20170604/34a8538fdca241568261997fb1742bcb_th.jpg) 

    

  * 直接引用。堆对象的布局得考虑类型数据的如何放置，栈中直接存储的是对象在堆中的具体地址。

    ![img](http://www.cnblogs.com/images/cnblogs_com/gscq073240/1061819/o_%e9%80%9a%e8%bf%87%e7%9b%b4%e6%8e%a5%e6%8c%87%e9%92%88%e8%ae%bf%e9%97%ae%e5%af%b9%e8%b1%a1.png) 

  * 总结。直接访问最大的好处就是速度快，节省了一次指针定位的时间开销，由于对象的访问是非常频繁的，累计出来的节省开销就非常可观，Sun HotSpot虚拟机采用的是直接访问。

### 3.内存溢出

  * 堆OOM
    * 对象数量超过最大堆容量限制
    * 定位内存泄露和内存溢出
  * 栈和本地方法栈
    * 线程请求栈的深度超过虚拟机所允许的最大深度。（stack overflow error）
    * 虚拟机在扩展时无法申请到足够多的内存空间。（OOM）
  * 方法区和运行时常量池
  * 本地直接内存溢出

## 二、垃圾收集器和内存分配策略

### 1.对象已死?

* 对象是否存活
  * 引用计数算法
    * 给对象中添加一个引用计数器，每当有一个地方引用它，计数器加1；引用失效，计数器减1。任何时刻计数器为0，表示该对象没有被使用。

    * 无法解决循环引用问题。虚拟机不是通过引用计数算法判断对象是否存活的。

      ![img](http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/YUYc62VIvE2xHo4wJUED2bXDvGMrEC5ftstZPicT32mabz2O1Y9GFpib3dUgpKL3oyJQe1tQBIwNHxGCv1rYeNbA/640?wx_fmt=png) 

  * 可达性分析算法

    * 通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）,当一个对象到GC Roots没有任何引用链相连，则证明该对象是不可用的。
    * 在Java语言中，可作为GC Roots对象包括以下几种：
      * 虚拟机栈（栈帧中的本地变量表）中引用的对象。
      * 方法区中类静态属性所引用的对象。
      * 方法区中常量引用的对象。
      * 本地方法栈中JNI（Native方法）引用的对象。

* 引用

  * 强引用（Strong Reference），强引用在程序中经常出现，如new关键字创建对象时引用，只要强引用还在，垃圾收集器永远不会回收掉引用的对象。
  * 软引用（Soft Reference），软引用用来描述一些还有用但非必须的对象。对于软引用关联的对象，在将要发生内存溢出之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。Soft Reference类实现软引用。
  * 弱引用（Weak Reference），软引用用来描述非必要对象，当垃圾收集器工作时，无论当前栈内存是否足够，都会回收掉被弱引用关联的对象。WeakReference类来实现弱引用。
  * 虚引用（Phantom Reference），虚引用称为幽灵引用或幻影引用，最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生命时间构成影响，也无法通过一个虚引用来获取对象实例，唯一的目的，是在该对象被收集器回收时收到一个系统通知。PhantomReference类实现虚引用。

* 生存还是死亡

  * 即使在可达性分析算法中不可达的对象，也并不是“非死不可”，真正死亡需要经历两次标记过程。
    * 对象在经过可达性算法之后，没有发现与GC Roots相连的引用链，那么它会被第一次标记并进行筛选，筛选条件是判断该对象是否有必要执行finalize()方法。当对象没有覆盖（重写）finalize()方法或虚拟机已经执行过finalize()方法时，虚拟机视为“没有必要执行”。
    * 如果对象被判定有必要执行finalize()方法，那么该对象会被放入F-Queue队列中，稍后由虚拟机自动创建一个低优先级的Finalizer线程去执行。这里所谓的”执行“是指虚拟机会触发这个方法，但并不承诺等待执行结果，原因是如果一个对象在finalize()方法中执行缓慢，或者发生死循环，将可能到F-Queue队列一直阻塞，导致整个内存回收系统崩溃。
    * finalize()方法时对象逃离的最后机会，稍后GC将对F-Queue队列中的对象进行第二次标记，如果想要拯救自己，只要重新与引用链上的任何对象关联，这样第二次标记时会把它移除F-Queue队列（即将回收的集合）。如果该对象这个时候没有逃脱，那基本上真的被回收了。

* 回收方法区

  * Java虚拟机规范中可以不要求在方法区（Hot Spots永久区）实现垃圾收集，在方法区进行垃圾收集，效率太低。
  * 永久代的代码收集主要收集废弃常量和无用的类两种。
    * 废弃常量。如果常量池中“abc”，没有被任何引用，如果发生内存回收，而且必要的化，“abc”常量会被清除常量池。
    * 无用的类。判定相对苛刻，必须同时满足下面三个要求：
      * 该类的所有实例都被回收，也就是在堆中不存在该类的任何实例。
      * 加载该类的ClasslLoader已经被回收
      * 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
      * `虚拟机可以对满足上述三个条件的类进行回收，但仅仅是可以，并不是一定。`

### 2.垃圾收集算法

* 标记-清除算法（Mark-Sweep）
  * 直接标记哪些对象需要回收，进行回收清除。
  * 特点
    * 效率低
    * 会产生内存碎片
* 复制算法（Copying）
  * 将内存划分为大小相同的两块区域，只使用其中一块。当这一块内存使用完，将还存活的对象复制到另一块空白区域，然后清除该区域对象。
  * 特点
    * 不会产生内存碎片
    * 内存利用率只有50%
* 标记-整理算法（Mark Compact）
  * 先标记出哪些对象需要回收，把被标记对象向一端移动，清理掉端边际以外的内存。
* 分代收集算法（Generational Collection）
  * 根据对象存活周期不同，讲内存划分为几块，采用不同的收集算法。新生代、老年代。
  * 新生代，每次回收会有大批对象死去，少量存活，采用复制算法。
  * 老年代，对象存活率较高，没有额外空间对它分配担保，才有标记清理或标记整理算法。

## 三、HotSpot的算法实现

### 1.枚举根节点

​	在可达性分析算法中，从GC Roots节点找到引用链为例，可作为GC Roots的节点一般为**全局引用（常量或类静态属性）或执行上线文（栈帧中的本地变量表）**，现在很多引用方法区都有数百兆，逐个检查引用，必定要消耗很多时间。

​	可达性分析算法对执行时间敏感，在执行该算法时，整个执行系统看起来像被冻结到某个时间点上，不能出现分析过程中对象引用不断变化的情况，否则无法保证分析结果的正确性。这一点是导致GC进行时必须停顿所有的Java执行线程（Stop The World）的一个重要原因，即时在号称不会发生停顿的CMS收集器中，枚举根节点也是必须要停顿的。	

​	目前主流的虚拟机都是采用准确式的GC，当执行系统停顿下来，不需要一个不漏检查完执行上下文和全局引用的位置，虚拟机应当有办法知道哪些地方存在引用。在HotSpot实现中，使用OopMap的数据结构来完成，类加载完成之后，HotSpot把对象内什么偏移量上是什么类型的数据计算出来了，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是被引用的。这样，在GC扫描的时候，只扫描被引用的位置。

### 2.安全点

​	在OopMap的协助下，JVM可以快速确定GC Roots枚举，但是存在引用关系变化，或者说OopMap内容变化的指令非常多，如果每条变化都产生一个OopMap，将会需要大量额外空间，这样GC的空间成本会很高。实际上，HotSpot没有为每条指令都生成OopMap，只是在“特定位置”记录这些信息，这些位置称为“安全点”，即程序执行的时候，只有在安全点才发生GC（程序暂停）。

​	Safepoint的选定既不能太多（频繁GC导致负荷增大），也不能太少（GC等待时间过长），所以安全点的选定的标准是“是否具有让程序长时间执行的特征”，例如方法调用，循环跳转，异常跳转等。

​	对于Safepoint，另一个需要考虑的问题是如何保证所有的线程（不包括JNI线程）都在安全点停下来，有两种方案：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）。

* 抢先式中断不需要线程的执行代码配合，在GC发生时，中断所有线程，如果发现有线程不在安全点上，恢复线程，让它执行到安全点，现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC。
* 主动中断的思想是，当GC需要中断线程时，不直接中断线程，而是设置一个标志，各个线程执行时轮询该标志，发现中断标志为真时自己主动中断挂起。轮询标志的地址和安全点重合，再加上创建对象分配内存的地方。

### 3.安全区域

​	Safepoint机制保证了程序执行时，在不太长时间就会遇到可进入GC的Safepoint。但程序不执行的时候，没有分配CPU时间，典型的例子是线程睡眠或阻塞状态，线程无法响应JVM的中断请求，无法执行到安全点中断自己，JVM也不太可能等待线程重新被分配CPU时间。这种情况，需要安全区域（Safe Region）来解决。

​	Safe Region是指在一段代码片段之中，对象引用关系不会发生变化。这个区域的任何地方都可以GC，可以把Safe Region是Safepoint的扩展。线程执行到Safe Region时，首先标志自己已经进入Safe Region，当在这段时间JVM要发起GC时，不用管标识自己为Safe Region状态的线程，在线程要离开Safe Region时，它要检查整个系统是否完成GC，如果完成，线程继续执行，否则必须等待，直到收到可以离开Safe Region的信号为止。

##  四、垃圾收集器

​	虽然我们对各个收集器进行比较，但并非挑选一个最好的收集器，因为目前为止还没有最好的收集器出现，更加没有万能的收集器，我们选择的只是对具体应用最适合的收集器。

![img](http://img-blog.csdnimg.cn/20181219110924217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzYyNzc1,size_16,color_FFFFFF,t_70) 

### 1.Serial收集器

* 最基本，历史最悠久的收集器，JDK1.3之前是新生代收集唯一的选择。
* 单线程收集器，它在垃圾收集时，必须暂停所有工作线程，直到它收集结束。
* Client模式下默认新生代收集器。

### 2.ParNew收集器

* Serial的多线程版本，单CPU下没Serial效率高，CPU增加ParNew效果明显。
* 除Serial外，只有ParNew能配合CMS的老年代收集器。

**并行（Parallel）：指多条垃圾收集线程并行执行，但是此时用户线程处于等待状态。**

**并发（Concurrent）：指用户线程和垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户线程在继续执行，而垃圾收集程序运行在另一个CPU上。**

### 3.Parallel Scavenge收集器

* 采用复制算法，并行的多线程收集器。
* 目标是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)。停顿时间越短适合需要用户交互的程序，而高吞吐量可以高效利用CPU时间，尽快完成运行任务，主要适合后台运算而不需要太多交互的任务。
* Parallel Scavenge收集器提供两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间`--XX:MaxGCPauseMillis`参数和直接设置吞吐量大小的`--XX:GCTimeRatio`参数。
* 吞吐量有限收集器，虚拟机会根据当前系统的运行情况，收集器性能监控信息，动态调整参数以提供最适合的停顿时间或最大吞吐量，这种调节方式称为GC自适应调节策略（GC Ergonomics）。

### 4.Serial Old收集器

* serial收集器老年代版本，单线程收集器，采用“标记-整理”算法。
* 主要给Client模式下老年代用。
* 如果在Server模式下，JDK1.5前与Parallel Scavenge收集器搭配使用；作为CMS收集器的备选。

### 5.Parallel Old收集器

* Parallel Scavenge收集器的老年代，多线程“标记-整理”算法。
* 配合新生代Parallel Scavenge收集器使用。

### 6.CMS收集器

* CMS收集器以获取最短回收停顿时间为目标。
* 标记-清除算法实现，分4个步骤
  * 初始标记。仅仅标记GC Roots能直接关联的对象，速度很快。时间：短
  * 并发标记。GC Roots Tracing的过程。时间：长
  * 重新标记。修正并发标记期间，被标记对象产生变化的部分。时间：中
  * 并发清除。
* 优点：并发收集，低停顿。
* 缺点：
  * 对CPU资源敏感。其实面向并发设计的程序都对CPU资源比较敏感，在并发阶段，虽然不会导致用户线程停顿，但会因此占用一部分CPU资源导致应用程序变慢，总吞吐量下降。CMS默认开启回收线程数为（CPU数量+3）/4，所消耗的资源随CPU的增加而下降。如果CPU不足4，CMS对用户程序的影响就会很大，此时虚拟机提出了“增量式并发收集器”（I-CMS）,使用抢占式来模拟多任务机制，就是在并发标记、清理的时候让GC线程和用户线程交替运行，尽量减少GC线程所独占资源的时间，这样整个GC时间会变长，对用户程序的影响就会显得少，但是下降没有很明显，所有虚拟机默认关闭，不推荐使用。
  * CMS无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理垃圾阶段，用户线程还在运行，伴随着程序的运行，会有新的垃圾不断产生，这部分垃圾在标记之后，CMS无法在当次收集中处理掉它们，这部分垃圾称为“浮动垃圾”。也是由于收集时，用户线程还在运行，，不能等到老年代几乎完成被填满时再收集，需要预留足够的内存空间给用户线程使用。JDK1.5，老年代68%后就会被激活，JDK1.6，92%，如果预留的内存不够用户程序使用，会出现“Concurrent Mode Failure”失败，这时会临时启用Serial Old收集器来重新对老年代的垃圾收集，这样停顿时间就很长了。
  * 由于CMS是采用”标记-清除“算法，所以收集结束会产生大量的内存碎片，碎片过多，会对大对象分配产生麻烦，往往老年代还有很多空间，但是无法找到足够连续的内存分配当前对象，不得不触发一次Full GC。解决方式：CMS收集器提供了一个`--XX:+UseCMSCompactAtFullCollection`开关的参数，默认开启，用于在CMS顶不住要进行Full GC时开启内存合并整理过程，但是内存整理过程无法并发进行，会导致停顿时间变长。此时虚拟机提供`--XX:CMSFullGCsBeforeCompaction`参数来设置执行多少次不压缩的Full GC后，跟着来一次压缩操作（默认为0，表示每次Full GC时都进行碎片整理）。

### 7.G1收集器

* G1（Garbage-First）收集器是当今收集器技术发展最前沿技术之一。
* G1是一款面向服务端应用的垃圾收集器，未来可以替换CMS收集器。
* 特点：
  * 并行与并发：G1能充分利用多CPU、多核环境下硬件资源。Java执行GC动作，G1收集器仍能通过并发的方式让Java程序继续运行。
  * 分代收集：虽然可以不依赖其他收集器独立管理整个GC堆，但它能采用不同的方式去处理新创建的对象和已经存活一段时间、熬过多次GC的旧对象以获取更好的收集效果。
  * 空间整合：整体基于“标记-整理”算法，局部（两个Region）采用“复制”算法。
  * 可预测停顿时间：减低停顿时间是CMS和G1共同关注点，但G1除了追求停顿外，会建立可预测的停顿时间模型，能让使用者明确指定在一个长度为Mms的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎是实时Java（RTSJ）的收集器特征了。
* 使用G1收集器时，Java堆的内存布局就与其他收集器有很大区别，它将堆分为多个大小相等的独立区域（Region），虽然还保留了新生代和老年代的概念，但是新生代和老年代不在隔离，他们都是一部分Region（不需要连续）的集合。
* G1收集器之所以能建立可预测的停顿时间模型，是因为它有计划的避免在整个Java堆中进行全区域的垃圾收集。G1会跟踪各个Region里面的垃圾堆积的价值（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这就是Garbage-First的由来）。
* Region不是独立的，存在不同Region对象的相互引用，在判断对象是否存活的可达性分析算法中如何避免全区域扫描。

### 8.GC日志

### 9.垃圾收集器参数总结

| 参数                           | 描述                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| UseSerialGC                    | 虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial + Serial Old的收集器组合进行内存回收 |
| UseParNewGC                    | 打开此开关后，使用ParNew + Serial Old的收集器组合进行内存回收 |
| UseConcMarkSweepGC             | 打开此开关后，使用ParNew+ CMS + Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用 |
| UseParallelGC                  | 虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old (PS Mark Sweep)的收集器组合进行内存回收 |
| UserParallelOldGC              | 打开此开关后，使用Parallel Scavenge + Parallel Old的收集器组合进行内存回收 |
| SurvivorRatio                  | 新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden: Survivor = 8:1 |
| PretenureSizeThreshold         | 直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配 |
| MaxTenuringThreshold           | 晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄就增加1，当超过这个参数值时就进入老年代 |
| UseAdaptiveSizePolicy          | 动态调整Java堆中各个区域的大小以及进入老年代的年龄           |
| HandlePromotionFailure         | 是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况 |
| ParallelGCThreads              | 设置并行GC时进行内存回收的线程数                             |
| GCTimeRatio                    | GC时间占总时间的比率，默认值是99， 即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效 |
| MaxGCPauseMillis               | 设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效  |
| CMSInitiatingOccupancyFraction | 设置CMS收集器在老年代时间被使用多少后触发垃圾收集。默认值为68%，仅在使用CMS收集器时生效 |
| UseCMSCompactAtFullCollection  | 设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效 |
| CMSFullGCsBeforeCompaction     | 设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理，仅在使用CMS收集器时生效 |

